/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AcceptDisputeResponse } from '../models';
// @ts-ignore
import { CreateDisputeEvidenceTextRequest } from '../models';
// @ts-ignore
import { CreateDisputeEvidenceTextResponse } from '../models';
// @ts-ignore
import { ListDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { ListDisputesResponse } from '../models';
// @ts-ignore
import { RemoveDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { RetrieveDisputeEvidenceResponse } from '../models';
// @ts-ignore
import { RetrieveDisputeResponse } from '../models';
// @ts-ignore
import { SubmitEvidenceResponse } from '../models';
/**
 * DisputesApi - axios parameter creator
 * @export
 */
export const DisputesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the sellerâ€™s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling acceptDispute.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/accept`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText: async (disputeId: string, body: CreateDisputeEvidenceTextRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling createDisputeEvidenceText.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDisputeEvidenceText.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence_text`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling listDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: async (cursor?: string, states?: string, locationId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (locationId !== undefined) {
                localVarQueryParameter['location_id'] = locationId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence: async (disputeId: string, evidenceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling removeDisputeEvidence.');
            }
            // verify required parameter 'evidenceId' is not null or undefined
            if (evidenceId === null || evidenceId === undefined) {
                throw new RequiredError('evidenceId','Required parameter evidenceId was null or undefined when calling removeDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence/{evidence_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)))
                .replace(`{${"evidence_id"}}`, encodeURIComponent(String(evidenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling retrieveDispute.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence: async (disputeId: string, evidenceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling retrieveDisputeEvidence.');
            }
            // verify required parameter 'evidenceId' is not null or undefined
            if (evidenceId === null || evidenceId === undefined) {
                throw new RequiredError('evidenceId','Required parameter evidenceId was null or undefined when calling retrieveDisputeEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/evidence/{evidence_id}`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)))
                .replace(`{${"evidence_id"}}`, encodeURIComponent(String(evidenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence: async (disputeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            if (disputeId === null || disputeId === undefined) {
                throw new RequiredError('disputeId','Required parameter disputeId was null or undefined when calling submitEvidence.');
            }
            const localVarPath = `/v2/disputes/{dispute_id}/submit-evidence`
                .replace(`{${"dispute_id"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisputesApi - functional programming interface
 * @export
 */
export const DisputesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the sellerâ€™s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDispute(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptDisputeResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).acceptDispute(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDisputeEvidenceTextResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).createDisputeEvidenceText(disputeId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDisputeEvidence(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).listDisputeEvidence(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDisputes(cursor?: string, states?: string, locationId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputesResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).listDisputes(cursor, states, locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).removeDisputeEvidence(disputeId, evidenceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDispute(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveDisputeResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).retrieveDispute(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveDisputeEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitEvidence(disputeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitEvidenceResponse>> {
            const localVarAxiosArgs = await DisputesApiAxiosParamCreator(configuration).submitEvidence(disputeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DisputesApi - factory interface
 * @export
 */
export const DisputesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the sellerâ€™s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
         * @summary AcceptDispute
         * @param {string} disputeId ID of the dispute you want to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDispute(disputeId: string, options?: any): AxiosPromise<AcceptDisputeResponse> {
            return DisputesApiFp(configuration).acceptDispute(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads text to use as evidence for a dispute challenge.
         * @summary CreateDisputeEvidenceText
         * @param {string} disputeId The ID of the dispute you want to upload evidence for.
         * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any): AxiosPromise<CreateDisputeEvidenceTextResponse> {
            return DisputesApiFp(configuration).createDisputeEvidenceText(disputeId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of evidence associated with a dispute.
         * @summary ListDisputeEvidence
         * @param {string} disputeId The ID of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputeEvidence(disputeId: string, options?: any): AxiosPromise<ListDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).listDisputeEvidence(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of disputes associated with a particular account.
         * @summary ListDisputes
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
         * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
         * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes(cursor?: string, states?: string, locationId?: string, options?: any): AxiosPromise<ListDisputesResponse> {
            return DisputesApiFp(configuration).listDisputes(cursor, states, locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
         * @summary RemoveDisputeEvidence
         * @param {string} disputeId The ID of the dispute you want to remove evidence from.
         * @param {string} evidenceId The ID of the evidence you want to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any): AxiosPromise<RemoveDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).removeDisputeEvidence(disputeId, evidenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific dispute.
         * @summary RetrieveDispute
         * @param {string} disputeId The ID of the dispute you want more details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute(disputeId: string, options?: any): AxiosPromise<RetrieveDisputeResponse> {
            return DisputesApiFp(configuration).retrieveDispute(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
         * @summary RetrieveDisputeEvidence
         * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
         * @param {string} evidenceId The ID of the evidence to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any): AxiosPromise<RetrieveDisputeEvidenceResponse> {
            return DisputesApiFp(configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
         * @summary SubmitEvidence
         * @param {string} disputeId The ID of the dispute you want to submit evidence for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvidence(disputeId: string, options?: any): AxiosPromise<SubmitEvidenceResponse> {
            return DisputesApiFp(configuration).submitEvidence(disputeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisputesApi - object-oriented interface
 * @export
 * @class DisputesApi
 * @extends {BaseAPI}
 */
export class DisputesApi extends BaseAPI {
    /**
     * Accepts loss on a dispute. Square returns the disputed amount to the cardholder and updates the dispute state to ACCEPTED.  Square debits the disputed amount from the sellerâ€™s Square account. If the Square account balance does not have sufficient funds, Square debits the associated bank account.
     * @summary AcceptDispute
     * @param {string} disputeId ID of the dispute you want to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public acceptDispute(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).acceptDispute(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads text to use as evidence for a dispute challenge.
     * @summary CreateDisputeEvidenceText
     * @param {string} disputeId The ID of the dispute you want to upload evidence for.
     * @param {CreateDisputeEvidenceTextRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public createDisputeEvidenceText(disputeId: string, body: CreateDisputeEvidenceTextRequest, options?: any) {
        return DisputesApiFp(this.configuration).createDisputeEvidenceText(disputeId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of evidence associated with a dispute.
     * @summary ListDisputeEvidence
     * @param {string} disputeId The ID of the dispute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public listDisputeEvidence(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).listDisputeEvidence(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of disputes associated with a particular account.
     * @summary ListDisputes
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this to retrieve the next set of results for the original query. For more information, see [Paginating](https://developer.squareup.com/docs/basics/api101/pagination).
     * @param {string} [states] The dispute states to filter the result. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or &#x60;LOST&#x60;).
     * @param {string} [locationId] The ID of the location for which to return  a list of disputes. If not specified, the endpoint returns all open disputes (dispute status is not &#x60;INQUIRY_CLOSED&#x60;, &#x60;WON&#x60;, or  &#x60;LOST&#x60;) associated with all locations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public listDisputes(cursor?: string, states?: string, locationId?: string, options?: any) {
        return DisputesApiFp(this.configuration).listDisputes(cursor, states, locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes specified evidence from a dispute.  Square does not send the bank any evidence that is removed. Also, you cannot remove evidence after submitting it to the bank using [SubmitEvidence](/reference/square/disputes-api/submit-evidence).
     * @summary RemoveDisputeEvidence
     * @param {string} disputeId The ID of the dispute you want to remove evidence from.
     * @param {string} evidenceId The ID of the evidence you want to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public removeDisputeEvidence(disputeId: string, evidenceId: string, options?: any) {
        return DisputesApiFp(this.configuration).removeDisputeEvidence(disputeId, evidenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific dispute.
     * @summary RetrieveDispute
     * @param {string} disputeId The ID of the dispute you want more details about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public retrieveDispute(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).retrieveDispute(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specific evidence metadata associated with a specific dispute.  You must maintain a copy of the evidence you upload if you want to reference it later. You cannot download the evidence after you upload it.
     * @summary RetrieveDisputeEvidence
     * @param {string} disputeId The ID of the dispute that you want to retrieve evidence from.
     * @param {string} evidenceId The ID of the evidence to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public retrieveDisputeEvidence(disputeId: string, evidenceId: string, options?: any) {
        return DisputesApiFp(this.configuration).retrieveDisputeEvidence(disputeId, evidenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits evidence to the cardholder\'s bank.  Before submitting evidence, Square compiles all available evidence. This includes evidence uploaded using the [CreateDisputeEvidenceFile](/reference/square/disputes-api/create-dispute-evidence-file) and [CreateDisputeEvidenceText](/reference/square/disputes-api/create-dispute-evidence-text) endpoints, and evidence automatically provided by Square, when available.
     * @summary SubmitEvidence
     * @param {string} disputeId The ID of the dispute you want to submit evidence for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public submitEvidence(disputeId: string, options?: any) {
        return DisputesApiFp(this.configuration).submitEvidence(disputeId, options).then((request) => request(this.axios, this.basePath));
    }
}
