/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { V1CashDrawerShift } from '../models';
// @ts-ignore
import { V1Employee } from '../models';
// @ts-ignore
import { V1EmployeeRole } from '../models';
// @ts-ignore
import { V1Timecard } from '../models';
// @ts-ignore
import { V1TimecardEvent } from '../models';
/**
 * V1EmployeesApi - axios parameter creator
 * @export
 */
export const V1EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Use the CreateEmployee endpoint to add an employee to a Square account. Employees created with the Connect API have an initial status of `INACTIVE`. Inactive employees cannot sign in to Square Point of Sale until they are activated from the Square Dashboard. Employee status cannot be changed with the Connect API.  <aside class=\"important\"> Employee entities cannot be deleted. To disable employee profiles, set the employee\'s status to <code>INACTIVE</code> </aside>
         * @summary CreateEmployee
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee: async (body: V1Employee, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEmployee.');
            }
            const localVarPath = `/v1/me/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an employee role you can then assign to employees.  Square accounts can include any number of roles that can be assigned to employees. These roles define the actions and permissions granted to an employee with that role. For example, an employee with a \"Shift Manager\" role might be able to issue refunds in Square Point of Sale, whereas an employee with a \"Clerk\" role might not.  Roles are assigned with the [V1UpdateEmployee](#endpoint-v1updateemployee) endpoint. An employee can have only one role at a time.  If an employee has no role, they have none of the permissions associated with roles. All employees can accept payments with Square Point of Sale.
         * @summary CreateEmployeeRole
         * @param {V1EmployeeRole} employeeRole An EmployeeRole object with a name and permissions, and an optional owner flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployeeRole: async (employeeRole: V1EmployeeRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeRole' is not null or undefined
            if (employeeRole === null || employeeRole === undefined) {
                throw new RequiredError('employeeRole','Required parameter employeeRole was null or undefined when calling createEmployeeRole.');
            }
            const localVarPath = `/v1/me/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof employeeRole !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(employeeRole !== undefined ? employeeRole : {}) : (employeeRole || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a timecard for an employee and clocks them in with an `API_CREATE` event and a `clockin_time` set to the current time unless the request provides a different value.  To import timecards from another system (rather than clocking someone in). Specify the `clockin_time` and* `clockout_time` in the request.  Timecards correspond to exactly one shift for a given employee, bounded by the `clockin_time` and `clockout_time` fields. An employee is considered clocked in if they have a timecard that doesn\'t have a `clockout_time` set. An employee that is currently clocked in cannot be clocked in a second time.
         * @summary CreateTimecard
         * @param {V1Timecard} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimecard: async (body: V1Timecard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTimecard.');
            }
            const localVarPath = `/v1/me/timecards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a timecard. Timecards can also be deleted through the Square Dashboard. Deleted timecards are still accessible through Connect API endpoints, but cannot be modified. The `deleted` field of the `Timecard` object indicates whether the timecard has been deleted.   __Note__: By default, deleted timecards appear alongside valid timecards in results returned by the [ListTimecards](#endpoint-v1employees-listtimecards) endpoint. To filter deleted timecards, include the `deleted` query parameter in the list request.  Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API.
         * @summary DeleteTimecard
         * @param {string} timecardId The ID of the timecard to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimecard: async (timecardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timecardId' is not null or undefined
            if (timecardId === null || timecardId === undefined) {
                throw new RequiredError('timecardId','Required parameter timecardId was null or undefined when calling deleteTimecard.');
            }
            const localVarPath = `/v1/me/timecards/{timecard_id}`
                .replace(`{${"timecard_id"}}`, encodeURIComponent(String(timecardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for all of a location\'s cash drawer shifts during a date range. The date range you specify cannot exceed 90 days.
         * @summary ListCashDrawerShifts
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} [order] The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC
         * @param {string} [beginTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
         * @param {string} [endTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCashDrawerShifts: async (locationId: string, order?: string, beginTime?: string, endTime?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listCashDrawerShifts.');
            }
            const localVarPath = `/v1/{location_id}/cash-drawer-shifts`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["PAYMENTS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides summary information for all of a business\'s employee roles.
         * @summary ListEmployeeRoles
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.Default value: ASC
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployeeRoles: async (order?: string, limit?: number, batchToken?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/me/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (batchToken !== undefined) {
                localVarQueryParameter['batch_token'] = batchToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides summary information for all of a business\'s employees.
         * @summary ListEmployees
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.      Default value: ASC
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
         * @param {string} [endUpdatedAt] If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginCreatedAt] If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endCreatedAt] If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [status] If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE).
         * @param {string} [externalId] If provided, the endpoint returns only employee entities with the specified external_id.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployees: async (order?: string, beginUpdatedAt?: string, endUpdatedAt?: string, beginCreatedAt?: string, endCreatedAt?: string, status?: string, externalId?: string, limit?: number, batchToken?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/me/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (beginUpdatedAt !== undefined) {
                localVarQueryParameter['begin_updated_at'] = beginUpdatedAt;
            }

            if (endUpdatedAt !== undefined) {
                localVarQueryParameter['end_updated_at'] = endUpdatedAt;
            }

            if (beginCreatedAt !== undefined) {
                localVarQueryParameter['begin_created_at'] = beginCreatedAt;
            }

            if (endCreatedAt !== undefined) {
                localVarQueryParameter['end_created_at'] = endCreatedAt;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (batchToken !== undefined) {
                localVarQueryParameter['batch_token'] = batchToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides summary information for all events associated with a particular timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary ListTimecardEvents
         * @param {string} timecardId The ID of the timecard to list events for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimecardEvents: async (timecardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timecardId' is not null or undefined
            if (timecardId === null || timecardId === undefined) {
                throw new RequiredError('timecardId','Required parameter timecardId was null or undefined when calling listTimecardEvents.');
            }
            const localVarPath = `/v1/me/timecards/{timecard_id}/events`
                .replace(`{${"timecard_id"}}`, encodeURIComponent(String(timecardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides summary information for all of a business\'s employee timecards.
         * @summary ListTimecards
         * @param {string} [order] The order in which timecards are listed in the response, based on their created_at field.
         * @param {string} [employeeId] If provided, the endpoint returns only timecards for the employee with the specified ID.
         * @param {string} [beginClockinTime] If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockinTime] If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginClockoutTime] If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockoutTime] If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endUpdatedAt] If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {boolean} [deleted] If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don\&#39;t provide this parameter, both valid and deleted timecards are returned.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimecards: async (order?: string, employeeId?: string, beginClockinTime?: string, endClockinTime?: string, beginClockoutTime?: string, endClockoutTime?: string, beginUpdatedAt?: string, endUpdatedAt?: string, deleted?: boolean, limit?: number, batchToken?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/me/timecards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employee_id'] = employeeId;
            }

            if (beginClockinTime !== undefined) {
                localVarQueryParameter['begin_clockin_time'] = beginClockinTime;
            }

            if (endClockinTime !== undefined) {
                localVarQueryParameter['end_clockin_time'] = endClockinTime;
            }

            if (beginClockoutTime !== undefined) {
                localVarQueryParameter['begin_clockout_time'] = beginClockoutTime;
            }

            if (endClockoutTime !== undefined) {
                localVarQueryParameter['end_clockout_time'] = endClockoutTime;
            }

            if (beginUpdatedAt !== undefined) {
                localVarQueryParameter['begin_updated_at'] = beginUpdatedAt;
            }

            if (endUpdatedAt !== undefined) {
                localVarQueryParameter['end_updated_at'] = endUpdatedAt;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (batchToken !== undefined) {
                localVarQueryParameter['batch_token'] = batchToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single cash drawer shift, including all events that occurred during the shift.
         * @summary RetrieveCashDrawerShift
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} shiftId The shift\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCashDrawerShift: async (locationId: string, shiftId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling retrieveCashDrawerShift.');
            }
            // verify required parameter 'shiftId' is not null or undefined
            if (shiftId === null || shiftId === undefined) {
                throw new RequiredError('shiftId','Required parameter shiftId was null or undefined when calling retrieveCashDrawerShift.');
            }
            const localVarPath = `/v1/{location_id}/cash-drawer-shifts/{shift_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"shift_id"}}`, encodeURIComponent(String(shiftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single employee.
         * @summary RetrieveEmployee
         * @param {string} employeeId The employee\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEmployee: async (employeeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling retrieveEmployee.');
            }
            const localVarPath = `/v1/me/employees/{employee_id}`
                .replace(`{${"employee_id"}}`, encodeURIComponent(String(employeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single employee role.
         * @summary RetrieveEmployeeRole
         * @param {string} roleId The role\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEmployeeRole: async (roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling retrieveEmployeeRole.');
            }
            const localVarPath = `/v1/me/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary RetrieveTimecard
         * @param {string} timecardId The timecard\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTimecard: async (timecardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timecardId' is not null or undefined
            if (timecardId === null || timecardId === undefined) {
                throw new RequiredError('timecardId','Required parameter timecardId was null or undefined when calling retrieveTimecard.');
            }
            const localVarPath = `/v1/me/timecards/{timecard_id}`
                .replace(`{${"timecard_id"}}`, encodeURIComponent(String(timecardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UpdateEmployee
         * @param {string} employeeId The ID of the role to modify.
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployee: async (employeeId: string, body: V1Employee, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling updateEmployee.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateEmployee.');
            }
            const localVarPath = `/v1/me/employees/{employee_id}`
                .replace(`{${"employee_id"}}`, encodeURIComponent(String(employeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an employee role.
         * @summary UpdateEmployeeRole
         * @param {string} roleId The ID of the role to modify.
         * @param {V1EmployeeRole} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeRole: async (roleId: string, body: V1EmployeeRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling updateEmployeeRole.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateEmployeeRole.');
            }
            const localVarPath = `/v1/me/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of a timecard with an `API_EDIT` event for the timecard. Updating an active timecard with a `clockout_time` clocks the employee out.
         * @summary UpdateTimecard
         * @param {string} timecardId TThe ID of the timecard to modify.
         * @param {V1Timecard} body An object containing the fields to POST for the request. See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimecard: async (timecardId: string, body: V1Timecard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timecardId' is not null or undefined
            if (timecardId === null || timecardId === undefined) {
                throw new RequiredError('timecardId','Required parameter timecardId was null or undefined when calling updateTimecard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTimecard.');
            }
            const localVarPath = `/v1/me/timecards/{timecard_id}`
                .replace(`{${"timecard_id"}}`, encodeURIComponent(String(timecardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1EmployeesApi - functional programming interface
 * @export
 */
export const V1EmployeesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *  Use the CreateEmployee endpoint to add an employee to a Square account. Employees created with the Connect API have an initial status of `INACTIVE`. Inactive employees cannot sign in to Square Point of Sale until they are activated from the Square Dashboard. Employee status cannot be changed with the Connect API.  <aside class=\"important\"> Employee entities cannot be deleted. To disable employee profiles, set the employee\'s status to <code>INACTIVE</code> </aside>
         * @summary CreateEmployee
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmployee(body: V1Employee, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Employee>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).createEmployee(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an employee role you can then assign to employees.  Square accounts can include any number of roles that can be assigned to employees. These roles define the actions and permissions granted to an employee with that role. For example, an employee with a \"Shift Manager\" role might be able to issue refunds in Square Point of Sale, whereas an employee with a \"Clerk\" role might not.  Roles are assigned with the [V1UpdateEmployee](#endpoint-v1updateemployee) endpoint. An employee can have only one role at a time.  If an employee has no role, they have none of the permissions associated with roles. All employees can accept payments with Square Point of Sale.
         * @summary CreateEmployeeRole
         * @param {V1EmployeeRole} employeeRole An EmployeeRole object with a name and permissions, and an optional owner flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmployeeRole(employeeRole: V1EmployeeRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EmployeeRole>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).createEmployeeRole(employeeRole, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a timecard for an employee and clocks them in with an `API_CREATE` event and a `clockin_time` set to the current time unless the request provides a different value.  To import timecards from another system (rather than clocking someone in). Specify the `clockin_time` and* `clockout_time` in the request.  Timecards correspond to exactly one shift for a given employee, bounded by the `clockin_time` and `clockout_time` fields. An employee is considered clocked in if they have a timecard that doesn\'t have a `clockout_time` set. An employee that is currently clocked in cannot be clocked in a second time.
         * @summary CreateTimecard
         * @param {V1Timecard} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimecard(body: V1Timecard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Timecard>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).createTimecard(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a timecard. Timecards can also be deleted through the Square Dashboard. Deleted timecards are still accessible through Connect API endpoints, but cannot be modified. The `deleted` field of the `Timecard` object indicates whether the timecard has been deleted.   __Note__: By default, deleted timecards appear alongside valid timecards in results returned by the [ListTimecards](#endpoint-v1employees-listtimecards) endpoint. To filter deleted timecards, include the `deleted` query parameter in the list request.  Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API.
         * @summary DeleteTimecard
         * @param {string} timecardId The ID of the timecard to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTimecard(timecardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).deleteTimecard(timecardId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for all of a location\'s cash drawer shifts during a date range. The date range you specify cannot exceed 90 days.
         * @summary ListCashDrawerShifts
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} [order] The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC
         * @param {string} [beginTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
         * @param {string} [endTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCashDrawerShifts(locationId: string, order?: string, beginTime?: string, endTime?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1CashDrawerShift>>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).listCashDrawerShifts(locationId, order, beginTime, endTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides summary information for all of a business\'s employee roles.
         * @summary ListEmployeeRoles
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.Default value: ASC
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmployeeRoles(order?: string, limit?: number, batchToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1EmployeeRole>>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).listEmployeeRoles(order, limit, batchToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides summary information for all of a business\'s employees.
         * @summary ListEmployees
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.      Default value: ASC
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
         * @param {string} [endUpdatedAt] If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginCreatedAt] If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endCreatedAt] If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [status] If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE).
         * @param {string} [externalId] If provided, the endpoint returns only employee entities with the specified external_id.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmployees(order?: string, beginUpdatedAt?: string, endUpdatedAt?: string, beginCreatedAt?: string, endCreatedAt?: string, status?: string, externalId?: string, limit?: number, batchToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Employee>>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).listEmployees(order, beginUpdatedAt, endUpdatedAt, beginCreatedAt, endCreatedAt, status, externalId, limit, batchToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides summary information for all events associated with a particular timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary ListTimecardEvents
         * @param {string} timecardId The ID of the timecard to list events for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimecardEvents(timecardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1TimecardEvent>>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).listTimecardEvents(timecardId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides summary information for all of a business\'s employee timecards.
         * @summary ListTimecards
         * @param {string} [order] The order in which timecards are listed in the response, based on their created_at field.
         * @param {string} [employeeId] If provided, the endpoint returns only timecards for the employee with the specified ID.
         * @param {string} [beginClockinTime] If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockinTime] If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginClockoutTime] If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockoutTime] If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endUpdatedAt] If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {boolean} [deleted] If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don\&#39;t provide this parameter, both valid and deleted timecards are returned.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimecards(order?: string, employeeId?: string, beginClockinTime?: string, endClockinTime?: string, beginClockoutTime?: string, endClockoutTime?: string, beginUpdatedAt?: string, endUpdatedAt?: string, deleted?: boolean, limit?: number, batchToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Timecard>>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).listTimecards(order, employeeId, beginClockinTime, endClockinTime, beginClockoutTime, endClockoutTime, beginUpdatedAt, endUpdatedAt, deleted, limit, batchToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single cash drawer shift, including all events that occurred during the shift.
         * @summary RetrieveCashDrawerShift
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} shiftId The shift\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCashDrawerShift(locationId: string, shiftId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CashDrawerShift>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).retrieveCashDrawerShift(locationId, shiftId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single employee.
         * @summary RetrieveEmployee
         * @param {string} employeeId The employee\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEmployee(employeeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Employee>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).retrieveEmployee(employeeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single employee role.
         * @summary RetrieveEmployeeRole
         * @param {string} roleId The role\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEmployeeRole(roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EmployeeRole>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).retrieveEmployeeRole(roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary RetrieveTimecard
         * @param {string} timecardId The timecard\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTimecard(timecardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Timecard>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).retrieveTimecard(timecardId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary UpdateEmployee
         * @param {string} employeeId The ID of the role to modify.
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmployee(employeeId: string, body: V1Employee, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Employee>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).updateEmployee(employeeId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an employee role.
         * @summary UpdateEmployeeRole
         * @param {string} roleId The ID of the role to modify.
         * @param {V1EmployeeRole} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmployeeRole(roleId: string, body: V1EmployeeRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EmployeeRole>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).updateEmployeeRole(roleId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of a timecard with an `API_EDIT` event for the timecard. Updating an active timecard with a `clockout_time` clocks the employee out.
         * @summary UpdateTimecard
         * @param {string} timecardId TThe ID of the timecard to modify.
         * @param {V1Timecard} body An object containing the fields to POST for the request. See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimecard(timecardId: string, body: V1Timecard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Timecard>> {
            const localVarAxiosArgs = await V1EmployeesApiAxiosParamCreator(configuration).updateTimecard(timecardId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * V1EmployeesApi - factory interface
 * @export
 */
export const V1EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *  Use the CreateEmployee endpoint to add an employee to a Square account. Employees created with the Connect API have an initial status of `INACTIVE`. Inactive employees cannot sign in to Square Point of Sale until they are activated from the Square Dashboard. Employee status cannot be changed with the Connect API.  <aside class=\"important\"> Employee entities cannot be deleted. To disable employee profiles, set the employee\'s status to <code>INACTIVE</code> </aside>
         * @summary CreateEmployee
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee(body: V1Employee, options?: any): AxiosPromise<V1Employee> {
            return V1EmployeesApiFp(configuration).createEmployee(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an employee role you can then assign to employees.  Square accounts can include any number of roles that can be assigned to employees. These roles define the actions and permissions granted to an employee with that role. For example, an employee with a \"Shift Manager\" role might be able to issue refunds in Square Point of Sale, whereas an employee with a \"Clerk\" role might not.  Roles are assigned with the [V1UpdateEmployee](#endpoint-v1updateemployee) endpoint. An employee can have only one role at a time.  If an employee has no role, they have none of the permissions associated with roles. All employees can accept payments with Square Point of Sale.
         * @summary CreateEmployeeRole
         * @param {V1EmployeeRole} employeeRole An EmployeeRole object with a name and permissions, and an optional owner flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployeeRole(employeeRole: V1EmployeeRole, options?: any): AxiosPromise<V1EmployeeRole> {
            return V1EmployeesApiFp(configuration).createEmployeeRole(employeeRole, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a timecard for an employee and clocks them in with an `API_CREATE` event and a `clockin_time` set to the current time unless the request provides a different value.  To import timecards from another system (rather than clocking someone in). Specify the `clockin_time` and* `clockout_time` in the request.  Timecards correspond to exactly one shift for a given employee, bounded by the `clockin_time` and `clockout_time` fields. An employee is considered clocked in if they have a timecard that doesn\'t have a `clockout_time` set. An employee that is currently clocked in cannot be clocked in a second time.
         * @summary CreateTimecard
         * @param {V1Timecard} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimecard(body: V1Timecard, options?: any): AxiosPromise<V1Timecard> {
            return V1EmployeesApiFp(configuration).createTimecard(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a timecard. Timecards can also be deleted through the Square Dashboard. Deleted timecards are still accessible through Connect API endpoints, but cannot be modified. The `deleted` field of the `Timecard` object indicates whether the timecard has been deleted.   __Note__: By default, deleted timecards appear alongside valid timecards in results returned by the [ListTimecards](#endpoint-v1employees-listtimecards) endpoint. To filter deleted timecards, include the `deleted` query parameter in the list request.  Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API.
         * @summary DeleteTimecard
         * @param {string} timecardId The ID of the timecard to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimecard(timecardId: string, options?: any): AxiosPromise<object> {
            return V1EmployeesApiFp(configuration).deleteTimecard(timecardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for all of a location\'s cash drawer shifts during a date range. The date range you specify cannot exceed 90 days.
         * @summary ListCashDrawerShifts
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} [order] The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC
         * @param {string} [beginTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
         * @param {string} [endTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCashDrawerShifts(locationId: string, order?: string, beginTime?: string, endTime?: string, options?: any): AxiosPromise<Array<V1CashDrawerShift>> {
            return V1EmployeesApiFp(configuration).listCashDrawerShifts(locationId, order, beginTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides summary information for all of a business\'s employee roles.
         * @summary ListEmployeeRoles
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.Default value: ASC
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployeeRoles(order?: string, limit?: number, batchToken?: string, options?: any): AxiosPromise<Array<V1EmployeeRole>> {
            return V1EmployeesApiFp(configuration).listEmployeeRoles(order, limit, batchToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides summary information for all of a business\'s employees.
         * @summary ListEmployees
         * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.      Default value: ASC
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
         * @param {string} [endUpdatedAt] If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginCreatedAt] If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endCreatedAt] If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [status] If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE).
         * @param {string} [externalId] If provided, the endpoint returns only employee entities with the specified external_id.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployees(order?: string, beginUpdatedAt?: string, endUpdatedAt?: string, beginCreatedAt?: string, endCreatedAt?: string, status?: string, externalId?: string, limit?: number, batchToken?: string, options?: any): AxiosPromise<Array<V1Employee>> {
            return V1EmployeesApiFp(configuration).listEmployees(order, beginUpdatedAt, endUpdatedAt, beginCreatedAt, endCreatedAt, status, externalId, limit, batchToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides summary information for all events associated with a particular timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary ListTimecardEvents
         * @param {string} timecardId The ID of the timecard to list events for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimecardEvents(timecardId: string, options?: any): AxiosPromise<Array<V1TimecardEvent>> {
            return V1EmployeesApiFp(configuration).listTimecardEvents(timecardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides summary information for all of a business\'s employee timecards.
         * @summary ListTimecards
         * @param {string} [order] The order in which timecards are listed in the response, based on their created_at field.
         * @param {string} [employeeId] If provided, the endpoint returns only timecards for the employee with the specified ID.
         * @param {string} [beginClockinTime] If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockinTime] If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginClockoutTime] If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endClockoutTime] If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
         * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
         * @param {string} [endUpdatedAt] If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
         * @param {boolean} [deleted] If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don\&#39;t provide this parameter, both valid and deleted timecards are returned.
         * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimecards(order?: string, employeeId?: string, beginClockinTime?: string, endClockinTime?: string, beginClockoutTime?: string, endClockoutTime?: string, beginUpdatedAt?: string, endUpdatedAt?: string, deleted?: boolean, limit?: number, batchToken?: string, options?: any): AxiosPromise<Array<V1Timecard>> {
            return V1EmployeesApiFp(configuration).listTimecards(order, employeeId, beginClockinTime, endClockinTime, beginClockoutTime, endClockoutTime, beginUpdatedAt, endUpdatedAt, deleted, limit, batchToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single cash drawer shift, including all events that occurred during the shift.
         * @summary RetrieveCashDrawerShift
         * @param {string} locationId The ID of the location to list cash drawer shifts for.
         * @param {string} shiftId The shift\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCashDrawerShift(locationId: string, shiftId: string, options?: any): AxiosPromise<V1CashDrawerShift> {
            return V1EmployeesApiFp(configuration).retrieveCashDrawerShift(locationId, shiftId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single employee.
         * @summary RetrieveEmployee
         * @param {string} employeeId The employee\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEmployee(employeeId: string, options?: any): AxiosPromise<V1Employee> {
            return V1EmployeesApiFp(configuration).retrieveEmployee(employeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single employee role.
         * @summary RetrieveEmployeeRole
         * @param {string} roleId The role\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEmployeeRole(roleId: string, options?: any): AxiosPromise<V1EmployeeRole> {
            return V1EmployeesApiFp(configuration).retrieveEmployeeRole(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
         * @summary RetrieveTimecard
         * @param {string} timecardId The timecard\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTimecard(timecardId: string, options?: any): AxiosPromise<V1Timecard> {
            return V1EmployeesApiFp(configuration).retrieveTimecard(timecardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UpdateEmployee
         * @param {string} employeeId The ID of the role to modify.
         * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployee(employeeId: string, body: V1Employee, options?: any): AxiosPromise<V1Employee> {
            return V1EmployeesApiFp(configuration).updateEmployee(employeeId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an employee role.
         * @summary UpdateEmployeeRole
         * @param {string} roleId The ID of the role to modify.
         * @param {V1EmployeeRole} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeRole(roleId: string, body: V1EmployeeRole, options?: any): AxiosPromise<V1EmployeeRole> {
            return V1EmployeesApiFp(configuration).updateEmployeeRole(roleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of a timecard with an `API_EDIT` event for the timecard. Updating an active timecard with a `clockout_time` clocks the employee out.
         * @summary UpdateTimecard
         * @param {string} timecardId TThe ID of the timecard to modify.
         * @param {V1Timecard} body An object containing the fields to POST for the request. See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimecard(timecardId: string, body: V1Timecard, options?: any): AxiosPromise<V1Timecard> {
            return V1EmployeesApiFp(configuration).updateTimecard(timecardId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1EmployeesApi - object-oriented interface
 * @export
 * @class V1EmployeesApi
 * @extends {BaseAPI}
 */
export class V1EmployeesApi extends BaseAPI {
    /**
     *  Use the CreateEmployee endpoint to add an employee to a Square account. Employees created with the Connect API have an initial status of `INACTIVE`. Inactive employees cannot sign in to Square Point of Sale until they are activated from the Square Dashboard. Employee status cannot be changed with the Connect API.  <aside class=\"important\"> Employee entities cannot be deleted. To disable employee profiles, set the employee\'s status to <code>INACTIVE</code> </aside>
     * @summary CreateEmployee
     * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public createEmployee(body: V1Employee, options?: any) {
        return V1EmployeesApiFp(this.configuration).createEmployee(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an employee role you can then assign to employees.  Square accounts can include any number of roles that can be assigned to employees. These roles define the actions and permissions granted to an employee with that role. For example, an employee with a \"Shift Manager\" role might be able to issue refunds in Square Point of Sale, whereas an employee with a \"Clerk\" role might not.  Roles are assigned with the [V1UpdateEmployee](#endpoint-v1updateemployee) endpoint. An employee can have only one role at a time.  If an employee has no role, they have none of the permissions associated with roles. All employees can accept payments with Square Point of Sale.
     * @summary CreateEmployeeRole
     * @param {V1EmployeeRole} employeeRole An EmployeeRole object with a name and permissions, and an optional owner flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public createEmployeeRole(employeeRole: V1EmployeeRole, options?: any) {
        return V1EmployeesApiFp(this.configuration).createEmployeeRole(employeeRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a timecard for an employee and clocks them in with an `API_CREATE` event and a `clockin_time` set to the current time unless the request provides a different value.  To import timecards from another system (rather than clocking someone in). Specify the `clockin_time` and* `clockout_time` in the request.  Timecards correspond to exactly one shift for a given employee, bounded by the `clockin_time` and `clockout_time` fields. An employee is considered clocked in if they have a timecard that doesn\'t have a `clockout_time` set. An employee that is currently clocked in cannot be clocked in a second time.
     * @summary CreateTimecard
     * @param {V1Timecard} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public createTimecard(body: V1Timecard, options?: any) {
        return V1EmployeesApiFp(this.configuration).createTimecard(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a timecard. Timecards can also be deleted through the Square Dashboard. Deleted timecards are still accessible through Connect API endpoints, but cannot be modified. The `deleted` field of the `Timecard` object indicates whether the timecard has been deleted.   __Note__: By default, deleted timecards appear alongside valid timecards in results returned by the [ListTimecards](#endpoint-v1employees-listtimecards) endpoint. To filter deleted timecards, include the `deleted` query parameter in the list request.  Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API.
     * @summary DeleteTimecard
     * @param {string} timecardId The ID of the timecard to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public deleteTimecard(timecardId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).deleteTimecard(timecardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for all of a location\'s cash drawer shifts during a date range. The date range you specify cannot exceed 90 days.
     * @summary ListCashDrawerShifts
     * @param {string} locationId The ID of the location to list cash drawer shifts for.
     * @param {string} [order] The order in which cash drawer shifts are listed in the response, based on their created_at field. Default value: ASC
     * @param {string} [beginTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time minus 90 days.
     * @param {string} [endTime] The beginning of the requested reporting period, in ISO 8601 format. Default value: The current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public listCashDrawerShifts(locationId: string, order?: string, beginTime?: string, endTime?: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).listCashDrawerShifts(locationId, order, beginTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides summary information for all of a business\'s employee roles.
     * @summary ListEmployeeRoles
     * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.Default value: ASC
     * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public listEmployeeRoles(order?: string, limit?: number, batchToken?: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).listEmployeeRoles(order, limit, batchToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides summary information for all of a business\'s employees.
     * @summary ListEmployees
     * @param {string} [order] The order in which employees are listed in the response, based on their created_at field.      Default value: ASC
     * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format
     * @param {string} [endUpdatedAt] If filtering results by there updated_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param {string} [beginCreatedAt] If filtering results by their created_at field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param {string} [endCreatedAt] If filtering results by their created_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param {string} [status] If provided, the endpoint returns only employee entities with the specified status (ACTIVE or INACTIVE).
     * @param {string} [externalId] If provided, the endpoint returns only employee entities with the specified external_id.
     * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public listEmployees(order?: string, beginUpdatedAt?: string, endUpdatedAt?: string, beginCreatedAt?: string, endCreatedAt?: string, status?: string, externalId?: string, limit?: number, batchToken?: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).listEmployees(order, beginUpdatedAt, endUpdatedAt, beginCreatedAt, endCreatedAt, status, externalId, limit, batchToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides summary information for all events associated with a particular timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
     * @summary ListTimecardEvents
     * @param {string} timecardId The ID of the timecard to list events for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public listTimecardEvents(timecardId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).listTimecardEvents(timecardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides summary information for all of a business\'s employee timecards.
     * @summary ListTimecards
     * @param {string} [order] The order in which timecards are listed in the response, based on their created_at field.
     * @param {string} [employeeId] If provided, the endpoint returns only timecards for the employee with the specified ID.
     * @param {string} [beginClockinTime] If filtering results by their clockin_time field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param {string} [endClockinTime] If filtering results by their clockin_time field, the end of the requested reporting period, in ISO 8601 format.
     * @param {string} [beginClockoutTime] If filtering results by their clockout_time field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param {string} [endClockoutTime] If filtering results by their clockout_time field, the end of the requested reporting period, in ISO 8601 format.
     * @param {string} [beginUpdatedAt] If filtering results by their updated_at field, the beginning of the requested reporting period, in ISO 8601 format.
     * @param {string} [endUpdatedAt] If filtering results by their updated_at field, the end of the requested reporting period, in ISO 8601 format.
     * @param {boolean} [deleted] If true, only deleted timecards are returned. If false, only valid timecards are returned.If you don\&#39;t provide this parameter, both valid and deleted timecards are returned.
     * @param {number} [limit] The maximum integer number of employee entities to return in a single response. Default 100, maximum 200.
     * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public listTimecards(order?: string, employeeId?: string, beginClockinTime?: string, endClockinTime?: string, beginClockoutTime?: string, endClockoutTime?: string, beginUpdatedAt?: string, endUpdatedAt?: string, deleted?: boolean, limit?: number, batchToken?: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).listTimecards(order, employeeId, beginClockinTime, endClockinTime, beginClockoutTime, endClockoutTime, beginUpdatedAt, endUpdatedAt, deleted, limit, batchToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single cash drawer shift, including all events that occurred during the shift.
     * @summary RetrieveCashDrawerShift
     * @param {string} locationId The ID of the location to list cash drawer shifts for.
     * @param {string} shiftId The shift\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public retrieveCashDrawerShift(locationId: string, shiftId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).retrieveCashDrawerShift(locationId, shiftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single employee.
     * @summary RetrieveEmployee
     * @param {string} employeeId The employee\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public retrieveEmployee(employeeId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).retrieveEmployee(employeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single employee role.
     * @summary RetrieveEmployeeRole
     * @param {string} roleId The role\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public retrieveEmployeeRole(roleId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).retrieveEmployeeRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single timecard.   <aside> Only approved accounts can manage their employees with Square. Unapproved accounts cannot use employee management features with the API. </aside>
     * @summary RetrieveTimecard
     * @param {string} timecardId The timecard\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public retrieveTimecard(timecardId: string, options?: any) {
        return V1EmployeesApiFp(this.configuration).retrieveTimecard(timecardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UpdateEmployee
     * @param {string} employeeId The ID of the role to modify.
     * @param {V1Employee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public updateEmployee(employeeId: string, body: V1Employee, options?: any) {
        return V1EmployeesApiFp(this.configuration).updateEmployee(employeeId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an employee role.
     * @summary UpdateEmployeeRole
     * @param {string} roleId The ID of the role to modify.
     * @param {V1EmployeeRole} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public updateEmployeeRole(roleId: string, body: V1EmployeeRole, options?: any) {
        return V1EmployeesApiFp(this.configuration).updateEmployeeRole(roleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of a timecard with an `API_EDIT` event for the timecard. Updating an active timecard with a `clockout_time` clocks the employee out.
     * @summary UpdateTimecard
     * @param {string} timecardId TThe ID of the timecard to modify.
     * @param {V1Timecard} body An object containing the fields to POST for the request. See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1EmployeesApi
     */
    public updateTimecard(timecardId: string, body: V1Timecard, options?: any) {
        return V1EmployeesApiFp(this.configuration).updateTimecard(timecardId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
