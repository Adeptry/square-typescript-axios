/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { V1AdjustInventoryRequest } from '../models';
// @ts-ignore
import { V1Category } from '../models';
// @ts-ignore
import { V1Discount } from '../models';
// @ts-ignore
import { V1Fee } from '../models';
// @ts-ignore
import { V1InventoryEntry } from '../models';
// @ts-ignore
import { V1Item } from '../models';
// @ts-ignore
import { V1ModifierList } from '../models';
// @ts-ignore
import { V1ModifierOption } from '../models';
// @ts-ignore
import { V1Page } from '../models';
// @ts-ignore
import { V1PageCell } from '../models';
// @ts-ignore
import { V1UpdateModifierListRequest } from '../models';
// @ts-ignore
import { V1Variation } from '../models';
/**
 * V1ItemsApi - axios parameter creator
 * @export
 */
export const V1ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adjusts the current available inventory of an item variation.
         * @summary AdjustInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} variationId The ID of the variation to adjust inventory information for.
         * @param {V1AdjustInventoryRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInventory: async (locationId: string, variationId: string, body: V1AdjustInventoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling adjustInventory.');
            }
            // verify required parameter 'variationId' is not null or undefined
            if (variationId === null || variationId === undefined) {
                throw new RequiredError('variationId','Required parameter variationId was null or undefined when calling adjustInventory.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling adjustInventory.');
            }
            const localVarPath = `/v1/{location_id}/inventory/{variation_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"variation_id"}}`, encodeURIComponent(String(variationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates a fee with an item so the fee is automatically applied to the item in Square Point of Sale.
         * @summary ApplyFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFee: async (locationId: string, itemId: string, feeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling applyFee.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling applyFee.');
            }
            // verify required parameter 'feeId' is not null or undefined
            if (feeId === null || feeId === undefined) {
                throw new RequiredError('feeId','Required parameter feeId was null or undefined when calling applyFee.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/fees/{fee_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"fee_id"}}`, encodeURIComponent(String(feeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates a modifier list with an item so the associated modifier options can be applied to the item.
         * @summary ApplyModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to apply.
         * @param {string} itemId The ID of the item to add the modifier list to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyModifierList: async (locationId: string, modifierListId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling applyModifierList.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling applyModifierList.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling applyModifierList.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/modifier-lists/{modifier_list_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an item category.
         * @summary CreateCategory
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (locationId: string, body: V1Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createCategory.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategory.');
            }
            const localVarPath = `/v1/{location_id}/categories`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a discount.
         * @summary CreateDiscount
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscount: async (locationId: string, body: V1Discount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createDiscount.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDiscount.');
            }
            const localVarPath = `/v1/{location_id}/discounts`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a fee (tax).
         * @summary CreateFee
         * @param {string} locationId The ID of the location to create a fee for.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee: async (locationId: string, body: V1Fee, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createFee.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createFee.');
            }
            const localVarPath = `/v1/{location_id}/fees`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an item and at least one variation for it.    Item-related entities include fields you can use to associate them with entities in a non-Square system.  When you create an item-related entity, you can optionally specify `id`. This value must be unique among all IDs ever specified for the account, including those specified by other applications. You can never reuse an entity ID. If you do not specify an ID, Square generates one for the entity.  Item variations have a `user_data` string that lets you associate arbitrary metadata with the variation. The string cannot exceed 255 characters.
         * @summary CreateItem
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (locationId: string, body: V1Item, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createItem.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createItem.');
            }
            const localVarPath = `/v1/{location_id}/items`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an item modifier list and at least 1 modifier option for it.
         * @summary CreateModifierList
         * @param {string} locationId The ID of the location to create a modifier list for.
         * @param {V1ModifierList} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModifierList: async (locationId: string, body: V1ModifierList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createModifierList.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createModifierList.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an item modifier option and adds it to a modifier list.
         * @summary CreateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModifierOption: async (locationId: string, modifierListId: string, body: V1ModifierOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createModifierOption.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling createModifierOption.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createModifierOption.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Favorites page in Square Point of Sale.
         * @summary CreatePage
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPage: async (locationId: string, body: V1Page, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createPage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPage.');
            }
            const localVarPath = `/v1/{location_id}/pages`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an item variation for an existing item.
         * @summary CreateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariation: async (locationId: string, itemId: string, body: V1Variation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling createVariation.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling createVariation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createVariation.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/variations`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing item category.   __DeleteCategory__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteCategoryRequest` object as documented below.
         * @summary DeleteCategory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} categoryId The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (locationId: string, categoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/v1/{location_id}/categories/{category_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing discount.   __DeleteDiscount__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteDiscountRequest` object as documented below.
         * @summary DeleteDiscount
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} discountId The ID of the discount to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscount: async (locationId: string, discountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteDiscount.');
            }
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new RequiredError('discountId','Required parameter discountId was null or undefined when calling deleteDiscount.');
            }
            const localVarPath = `/v1/{location_id}/discounts/{discount_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing fee (tax).   __DeleteFee__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteFeeRequest` object as documented below.
         * @summary DeleteFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFee: async (locationId: string, feeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteFee.');
            }
            // verify required parameter 'feeId' is not null or undefined
            if (feeId === null || feeId === undefined) {
                throw new RequiredError('feeId','Required parameter feeId was null or undefined when calling deleteFee.');
            }
            const localVarPath = `/v1/{location_id}/fees/{fee_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"fee_id"}}`, encodeURIComponent(String(feeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing item and all item variations associated with it.   __DeleteItem__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteItemRequest` object as documented below.
         * @summary DeleteItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (locationId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing item modifier list and all modifier options associated with it.   __DeleteModifierList__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierListRequest` object as documented below.
         * @summary DeleteModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModifierList: async (locationId: string, modifierListId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteModifierList.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling deleteModifierList.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing item modifier option from a modifier list.   __DeleteModifierOption__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierOptionRequest` object.
         * @summary DeleteModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModifierOption: async (locationId: string, modifierListId: string, modifierOptionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteModifierOption.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling deleteModifierOption.');
            }
            // verify required parameter 'modifierOptionId' is not null or undefined
            if (modifierOptionId === null || modifierOptionId === undefined) {
                throw new RequiredError('modifierOptionId','Required parameter modifierOptionId was null or undefined when calling deleteModifierOption.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options/{modifier_option_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)))
                .replace(`{${"modifier_option_id"}}`, encodeURIComponent(String(modifierOptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing Favorites page and all of its cells.   __DeletePage__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageRequest` object.
         * @summary DeletePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage: async (locationId: string, pageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deletePage.');
            }
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling deletePage.');
            }
            const localVarPath = `/v1/{location_id}/pages/{page_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a cell from a Favorites page in Square Point of Sale.   __DeletePageCell__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageCellRequest` object as documented below.
         * @summary DeletePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {string} [row] The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
         * @param {string} [column] The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageCell: async (locationId: string, pageId: string, row?: string, column?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deletePageCell.');
            }
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling deletePageCell.');
            }
            const localVarPath = `/v1/{location_id}/pages/{page_id}/cells`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (row !== undefined) {
                localVarQueryParameter['row'] = row;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing item variation from an item.   __DeleteVariation__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteVariationRequest` object as documented below.
         * @summary DeleteVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to delete.
         * @param {string} variationId The ID of the variation to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariation: async (locationId: string, itemId: string, variationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling deleteVariation.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteVariation.');
            }
            // verify required parameter 'variationId' is not null or undefined
            if (variationId === null || variationId === undefined) {
                throw new RequiredError('variationId','Required parameter variationId was null or undefined when calling deleteVariation.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/variations/{variation_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"variation_id"}}`, encodeURIComponent(String(variationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the item categories for a given location.
         * @summary ListCategories
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories: async (locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listCategories.');
            }
            const localVarPath = `/v1/{location_id}/categories`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the discounts for a given location.
         * @summary ListDiscounts
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDiscounts: async (locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listDiscounts.');
            }
            const localVarPath = `/v1/{location_id}/discounts`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the fees (taxes) for a given location.
         * @summary ListFees
         * @param {string} locationId The ID of the location to list fees for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFees: async (locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listFees.');
            }
            const localVarPath = `/v1/{location_id}/fees`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides inventory information for all inventory-enabled item variations.
         * @summary ListInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {number} [limit] The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInventory: async (locationId: string, limit?: number, batchToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listInventory.');
            }
            const localVarPath = `/v1/{location_id}/inventory`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (batchToken !== undefined) {
                localVarQueryParameter['batch_token'] = batchToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides summary information of all items for a given location.
         * @summary ListItems
         * @param {string} locationId The ID of the location to list items for.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems: async (locationId: string, batchToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listItems.');
            }
            const localVarPath = `/v1/{location_id}/items`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (batchToken !== undefined) {
                localVarQueryParameter['batch_token'] = batchToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the modifier lists for a given location.
         * @summary ListModifierLists
         * @param {string} locationId The ID of the location to list modifier lists for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModifierLists: async (locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listModifierLists.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Favorites pages (in Square Point of Sale) for a given location.
         * @summary ListPages
         * @param {string} locationId The ID of the location to list Favorites pages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPages: async (locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling listPages.');
            }
            const localVarPath = `/v1/{location_id}/pages`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a fee assocation from an item so the fee is no longer automatically applied to the item in Square Point of Sale.
         * @summary RemoveFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFee: async (locationId: string, itemId: string, feeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling removeFee.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling removeFee.');
            }
            // verify required parameter 'feeId' is not null or undefined
            if (feeId === null || feeId === undefined) {
                throw new RequiredError('feeId','Required parameter feeId was null or undefined when calling removeFee.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/fees/{fee_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"fee_id"}}`, encodeURIComponent(String(feeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a modifier list association from an item so the modifier options from the list can no longer be applied to the item.
         * @summary RemoveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to remove.
         * @param {string} itemId The ID of the item to remove the modifier list from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeModifierList: async (locationId: string, modifierListId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling removeModifierList.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling removeModifierList.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling removeModifierList.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/modifier-lists/{modifier_list_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single item, including associated modifier lists and fees.
         * @summary RetrieveItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItem: async (locationId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling retrieveItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling retrieveItem.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides the details for a single modifier list.
         * @summary RetrieveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The modifier list\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModifierList: async (locationId: string, modifierListId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling retrieveModifierList.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling retrieveModifierList.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing item category.
         * @summary UpdateCategory
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} categoryId The ID of the category to edit.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (locationId: string, categoryId: string, body: V1Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling updateCategory.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCategory.');
            }
            const localVarPath = `/v1/{location_id}/categories/{category_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing discount.
         * @summary UpdateDiscount
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} discountId The ID of the discount to edit.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscount: async (locationId: string, discountId: string, body: V1Discount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateDiscount.');
            }
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new RequiredError('discountId','Required parameter discountId was null or undefined when calling updateDiscount.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDiscount.');
            }
            const localVarPath = `/v1/{location_id}/discounts/{discount_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing fee (tax).
         * @summary UpdateFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to edit.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFee: async (locationId: string, feeId: string, body: V1Fee, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateFee.');
            }
            // verify required parameter 'feeId' is not null or undefined
            if (feeId === null || feeId === undefined) {
                throw new RequiredError('feeId','Required parameter feeId was null or undefined when calling updateFee.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateFee.');
            }
            const localVarPath = `/v1/{location_id}/fees/{fee_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"fee_id"}}`, encodeURIComponent(String(feeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the core details of an existing item.
         * @summary UpdateItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (locationId: string, itemId: string, body: V1Item, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateItem.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing item modifier list.
         * @summary UpdateModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1UpdateModifierListRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModifierList: async (locationId: string, modifierListId: string, body: V1UpdateModifierListRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateModifierList.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling updateModifierList.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateModifierList.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing item modifier option.
         * @summary UpdateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModifierOption: async (locationId: string, modifierListId: string, modifierOptionId: string, body: V1ModifierOption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateModifierOption.');
            }
            // verify required parameter 'modifierListId' is not null or undefined
            if (modifierListId === null || modifierListId === undefined) {
                throw new RequiredError('modifierListId','Required parameter modifierListId was null or undefined when calling updateModifierOption.');
            }
            // verify required parameter 'modifierOptionId' is not null or undefined
            if (modifierOptionId === null || modifierOptionId === undefined) {
                throw new RequiredError('modifierOptionId','Required parameter modifierOptionId was null or undefined when calling updateModifierOption.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateModifierOption.');
            }
            const localVarPath = `/v1/{location_id}/modifier-lists/{modifier_list_id}/modifier-options/{modifier_option_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"modifier_list_id"}}`, encodeURIComponent(String(modifierListId)))
                .replace(`{${"modifier_option_id"}}`, encodeURIComponent(String(modifierOptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of a Favorites page in Square Point of Sale.
         * @summary UpdatePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location
         * @param {string} pageId The ID of the page to modify.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage: async (locationId: string, pageId: string, body: V1Page, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updatePage.');
            }
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling updatePage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePage.');
            }
            const localVarPath = `/v1/{location_id}/pages/{page_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies a cell of a Favorites page in Square Point of Sale.
         * @summary UpdatePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page the cell belongs to.
         * @param {V1PageCell} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageCell: async (locationId: string, pageId: string, body: V1PageCell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updatePageCell.');
            }
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling updatePageCell.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePageCell.');
            }
            const localVarPath = `/v1/{location_id}/pages/{page_id}/cells`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies the details of an existing item variation.
         * @summary UpdateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {string} variationId The ID of the variation to modify.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVariation: async (locationId: string, itemId: string, variationId: string, body: V1Variation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling updateVariation.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateVariation.');
            }
            // verify required parameter 'variationId' is not null or undefined
            if (variationId === null || variationId === undefined) {
                throw new RequiredError('variationId','Required parameter variationId was null or undefined when calling updateVariation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateVariation.');
            }
            const localVarPath = `/v1/{location_id}/items/{item_id}/variations/{variation_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"variation_id"}}`, encodeURIComponent(String(variationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["ITEMS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1ItemsApi - functional programming interface
 * @export
 */
export const V1ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adjusts the current available inventory of an item variation.
         * @summary AdjustInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} variationId The ID of the variation to adjust inventory information for.
         * @param {V1AdjustInventoryRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adjustInventory(locationId: string, variationId: string, body: V1AdjustInventoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InventoryEntry>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).adjustInventory(locationId, variationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Associates a fee with an item so the fee is automatically applied to the item in Square Point of Sale.
         * @summary ApplyFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyFee(locationId: string, itemId: string, feeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).applyFee(locationId, itemId, feeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Associates a modifier list with an item so the associated modifier options can be applied to the item.
         * @summary ApplyModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to apply.
         * @param {string} itemId The ID of the item to add the modifier list to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyModifierList(locationId: string, modifierListId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).applyModifierList(locationId, modifierListId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an item category.
         * @summary CreateCategory
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(locationId: string, body: V1Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Category>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createCategory(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a discount.
         * @summary CreateDiscount
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscount(locationId: string, body: V1Discount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Discount>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createDiscount(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a fee (tax).
         * @summary CreateFee
         * @param {string} locationId The ID of the location to create a fee for.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFee(locationId: string, body: V1Fee, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Fee>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createFee(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an item and at least one variation for it.    Item-related entities include fields you can use to associate them with entities in a non-Square system.  When you create an item-related entity, you can optionally specify `id`. This value must be unique among all IDs ever specified for the account, including those specified by other applications. You can never reuse an entity ID. If you do not specify an ID, Square generates one for the entity.  Item variations have a `user_data` string that lets you associate arbitrary metadata with the variation. The string cannot exceed 255 characters.
         * @summary CreateItem
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(locationId: string, body: V1Item, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createItem(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an item modifier list and at least 1 modifier option for it.
         * @summary CreateModifierList
         * @param {string} locationId The ID of the location to create a modifier list for.
         * @param {V1ModifierList} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModifierList(locationId: string, body: V1ModifierList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierList>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createModifierList(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an item modifier option and adds it to a modifier list.
         * @summary CreateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModifierOption(locationId: string, modifierListId: string, body: V1ModifierOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierOption>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createModifierOption(locationId, modifierListId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Favorites page in Square Point of Sale.
         * @summary CreatePage
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPage(locationId: string, body: V1Page, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Page>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createPage(locationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates an item variation for an existing item.
         * @summary CreateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariation(locationId: string, itemId: string, body: V1Variation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Variation>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).createVariation(locationId, itemId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing item category.   __DeleteCategory__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteCategoryRequest` object as documented below.
         * @summary DeleteCategory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} categoryId The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(locationId: string, categoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Category>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteCategory(locationId, categoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing discount.   __DeleteDiscount__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteDiscountRequest` object as documented below.
         * @summary DeleteDiscount
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} discountId The ID of the discount to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscount(locationId: string, discountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Discount>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteDiscount(locationId, discountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing fee (tax).   __DeleteFee__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteFeeRequest` object as documented below.
         * @summary DeleteFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFee(locationId: string, feeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Fee>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteFee(locationId, feeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing item and all item variations associated with it.   __DeleteItem__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteItemRequest` object as documented below.
         * @summary DeleteItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(locationId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteItem(locationId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing item modifier list and all modifier options associated with it.   __DeleteModifierList__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierListRequest` object as documented below.
         * @summary DeleteModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModifierList(locationId: string, modifierListId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierList>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteModifierList(locationId, modifierListId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing item modifier option from a modifier list.   __DeleteModifierOption__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierOptionRequest` object.
         * @summary DeleteModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierOption>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteModifierOption(locationId, modifierListId, modifierOptionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing Favorites page and all of its cells.   __DeletePage__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageRequest` object.
         * @summary DeletePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePage(locationId: string, pageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Page>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deletePage(locationId, pageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a cell from a Favorites page in Square Point of Sale.   __DeletePageCell__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageCellRequest` object as documented below.
         * @summary DeletePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {string} [row] The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
         * @param {string} [column] The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePageCell(locationId: string, pageId: string, row?: string, column?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Page>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deletePageCell(locationId, pageId, row, column, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing item variation from an item.   __DeleteVariation__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteVariationRequest` object as documented below.
         * @summary DeleteVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to delete.
         * @param {string} variationId The ID of the variation to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariation(locationId: string, itemId: string, variationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Variation>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).deleteVariation(locationId, itemId, variationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all the item categories for a given location.
         * @summary ListCategories
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategories(locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Category>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listCategories(locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all the discounts for a given location.
         * @summary ListDiscounts
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDiscounts(locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Discount>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listDiscounts(locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all the fees (taxes) for a given location.
         * @summary ListFees
         * @param {string} locationId The ID of the location to list fees for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFees(locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Fee>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listFees(locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides inventory information for all inventory-enabled item variations.
         * @summary ListInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {number} [limit] The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInventory(locationId: string, limit?: number, batchToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1InventoryEntry>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listInventory(locationId, limit, batchToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides summary information of all items for a given location.
         * @summary ListItems
         * @param {string} locationId The ID of the location to list items for.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItems(locationId: string, batchToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Item>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listItems(locationId, batchToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all the modifier lists for a given location.
         * @summary ListModifierLists
         * @param {string} locationId The ID of the location to list modifier lists for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModifierLists(locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1ModifierList>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listModifierLists(locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all Favorites pages (in Square Point of Sale) for a given location.
         * @summary ListPages
         * @param {string} locationId The ID of the location to list Favorites pages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPages(locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1Page>>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).listPages(locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a fee assocation from an item so the fee is no longer automatically applied to the item in Square Point of Sale.
         * @summary RemoveFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFee(locationId: string, itemId: string, feeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).removeFee(locationId, itemId, feeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a modifier list association from an item so the modifier options from the list can no longer be applied to the item.
         * @summary RemoveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to remove.
         * @param {string} itemId The ID of the item to remove the modifier list from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeModifierList(locationId: string, modifierListId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).removeModifierList(locationId, modifierListId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single item, including associated modifier lists and fees.
         * @summary RetrieveItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItem(locationId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).retrieveItem(locationId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides the details for a single modifier list.
         * @summary RetrieveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The modifier list\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveModifierList(locationId: string, modifierListId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierList>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).retrieveModifierList(locationId, modifierListId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing item category.
         * @summary UpdateCategory
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} categoryId The ID of the category to edit.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(locationId: string, categoryId: string, body: V1Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Category>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateCategory(locationId, categoryId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing discount.
         * @summary UpdateDiscount
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} discountId The ID of the discount to edit.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscount(locationId: string, discountId: string, body: V1Discount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Discount>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateDiscount(locationId, discountId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing fee (tax).
         * @summary UpdateFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to edit.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFee(locationId: string, feeId: string, body: V1Fee, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Fee>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateFee(locationId, feeId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the core details of an existing item.
         * @summary UpdateItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(locationId: string, itemId: string, body: V1Item, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Item>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateItem(locationId, itemId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing item modifier list.
         * @summary UpdateModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1UpdateModifierListRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModifierList(locationId: string, modifierListId: string, body: V1UpdateModifierListRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierList>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateModifierList(locationId, modifierListId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing item modifier option.
         * @summary UpdateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, body: V1ModifierOption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ModifierOption>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateModifierOption(locationId, modifierListId, modifierOptionId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of a Favorites page in Square Point of Sale.
         * @summary UpdatePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location
         * @param {string} pageId The ID of the page to modify.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePage(locationId: string, pageId: string, body: V1Page, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Page>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updatePage(locationId, pageId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies a cell of a Favorites page in Square Point of Sale.
         * @summary UpdatePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page the cell belongs to.
         * @param {V1PageCell} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageCell(locationId: string, pageId: string, body: V1PageCell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Page>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updatePageCell(locationId, pageId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies the details of an existing item variation.
         * @summary UpdateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {string} variationId The ID of the variation to modify.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVariation(locationId: string, itemId: string, variationId: string, body: V1Variation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Variation>> {
            const localVarAxiosArgs = await V1ItemsApiAxiosParamCreator(configuration).updateVariation(locationId, itemId, variationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * V1ItemsApi - factory interface
 * @export
 */
export const V1ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adjusts the current available inventory of an item variation.
         * @summary AdjustInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} variationId The ID of the variation to adjust inventory information for.
         * @param {V1AdjustInventoryRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInventory(locationId: string, variationId: string, body: V1AdjustInventoryRequest, options?: any): AxiosPromise<V1InventoryEntry> {
            return V1ItemsApiFp(configuration).adjustInventory(locationId, variationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Associates a fee with an item so the fee is automatically applied to the item in Square Point of Sale.
         * @summary ApplyFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFee(locationId: string, itemId: string, feeId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).applyFee(locationId, itemId, feeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Associates a modifier list with an item so the associated modifier options can be applied to the item.
         * @summary ApplyModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to apply.
         * @param {string} itemId The ID of the item to add the modifier list to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyModifierList(locationId: string, modifierListId: string, itemId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).applyModifierList(locationId, modifierListId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an item category.
         * @summary CreateCategory
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(locationId: string, body: V1Category, options?: any): AxiosPromise<V1Category> {
            return V1ItemsApiFp(configuration).createCategory(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a discount.
         * @summary CreateDiscount
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscount(locationId: string, body: V1Discount, options?: any): AxiosPromise<V1Discount> {
            return V1ItemsApiFp(configuration).createDiscount(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a fee (tax).
         * @summary CreateFee
         * @param {string} locationId The ID of the location to create a fee for.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee(locationId: string, body: V1Fee, options?: any): AxiosPromise<V1Fee> {
            return V1ItemsApiFp(configuration).createFee(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an item and at least one variation for it.    Item-related entities include fields you can use to associate them with entities in a non-Square system.  When you create an item-related entity, you can optionally specify `id`. This value must be unique among all IDs ever specified for the account, including those specified by other applications. You can never reuse an entity ID. If you do not specify an ID, Square generates one for the entity.  Item variations have a `user_data` string that lets you associate arbitrary metadata with the variation. The string cannot exceed 255 characters.
         * @summary CreateItem
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(locationId: string, body: V1Item, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).createItem(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an item modifier list and at least 1 modifier option for it.
         * @summary CreateModifierList
         * @param {string} locationId The ID of the location to create a modifier list for.
         * @param {V1ModifierList} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModifierList(locationId: string, body: V1ModifierList, options?: any): AxiosPromise<V1ModifierList> {
            return V1ItemsApiFp(configuration).createModifierList(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an item modifier option and adds it to a modifier list.
         * @summary CreateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModifierOption(locationId: string, modifierListId: string, body: V1ModifierOption, options?: any): AxiosPromise<V1ModifierOption> {
            return V1ItemsApiFp(configuration).createModifierOption(locationId, modifierListId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Favorites page in Square Point of Sale.
         * @summary CreatePage
         * @param {string} locationId The ID of the location to create an item for.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPage(locationId: string, body: V1Page, options?: any): AxiosPromise<V1Page> {
            return V1ItemsApiFp(configuration).createPage(locationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an item variation for an existing item.
         * @summary CreateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariation(locationId: string, itemId: string, body: V1Variation, options?: any): AxiosPromise<V1Variation> {
            return V1ItemsApiFp(configuration).createVariation(locationId, itemId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing item category.   __DeleteCategory__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteCategoryRequest` object as documented below.
         * @summary DeleteCategory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} categoryId The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(locationId: string, categoryId: string, options?: any): AxiosPromise<V1Category> {
            return V1ItemsApiFp(configuration).deleteCategory(locationId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing discount.   __DeleteDiscount__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteDiscountRequest` object as documented below.
         * @summary DeleteDiscount
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} discountId The ID of the discount to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscount(locationId: string, discountId: string, options?: any): AxiosPromise<V1Discount> {
            return V1ItemsApiFp(configuration).deleteDiscount(locationId, discountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing fee (tax).   __DeleteFee__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteFeeRequest` object as documented below.
         * @summary DeleteFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFee(locationId: string, feeId: string, options?: any): AxiosPromise<V1Fee> {
            return V1ItemsApiFp(configuration).deleteFee(locationId, feeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing item and all item variations associated with it.   __DeleteItem__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteItemRequest` object as documented below.
         * @summary DeleteItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(locationId: string, itemId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).deleteItem(locationId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing item modifier list and all modifier options associated with it.   __DeleteModifierList__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierListRequest` object as documented below.
         * @summary DeleteModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModifierList(locationId: string, modifierListId: string, options?: any): AxiosPromise<V1ModifierList> {
            return V1ItemsApiFp(configuration).deleteModifierList(locationId, modifierListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing item modifier option from a modifier list.   __DeleteModifierOption__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierOptionRequest` object.
         * @summary DeleteModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to delete.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, options?: any): AxiosPromise<V1ModifierOption> {
            return V1ItemsApiFp(configuration).deleteModifierOption(locationId, modifierListId, modifierOptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing Favorites page and all of its cells.   __DeletePage__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageRequest` object.
         * @summary DeletePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage(locationId: string, pageId: string, options?: any): AxiosPromise<V1Page> {
            return V1ItemsApiFp(configuration).deletePage(locationId, pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a cell from a Favorites page in Square Point of Sale.   __DeletePageCell__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageCellRequest` object as documented below.
         * @summary DeletePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page to delete.
         * @param {string} [row] The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
         * @param {string} [column] The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageCell(locationId: string, pageId: string, row?: string, column?: string, options?: any): AxiosPromise<V1Page> {
            return V1ItemsApiFp(configuration).deletePageCell(locationId, pageId, row, column, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing item variation from an item.   __DeleteVariation__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteVariationRequest` object as documented below.
         * @summary DeleteVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to delete.
         * @param {string} variationId The ID of the variation to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariation(locationId: string, itemId: string, variationId: string, options?: any): AxiosPromise<V1Variation> {
            return V1ItemsApiFp(configuration).deleteVariation(locationId, itemId, variationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the item categories for a given location.
         * @summary ListCategories
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories(locationId: string, options?: any): AxiosPromise<Array<V1Category>> {
            return V1ItemsApiFp(configuration).listCategories(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the discounts for a given location.
         * @summary ListDiscounts
         * @param {string} locationId The ID of the location to list categories for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDiscounts(locationId: string, options?: any): AxiosPromise<Array<V1Discount>> {
            return V1ItemsApiFp(configuration).listDiscounts(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the fees (taxes) for a given location.
         * @summary ListFees
         * @param {string} locationId The ID of the location to list fees for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFees(locationId: string, options?: any): AxiosPromise<Array<V1Fee>> {
            return V1ItemsApiFp(configuration).listFees(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides inventory information for all inventory-enabled item variations.
         * @summary ListInventory
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {number} [limit] The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInventory(locationId: string, limit?: number, batchToken?: string, options?: any): AxiosPromise<Array<V1InventoryEntry>> {
            return V1ItemsApiFp(configuration).listInventory(locationId, limit, batchToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides summary information of all items for a given location.
         * @summary ListItems
         * @param {string} locationId The ID of the location to list items for.
         * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(locationId: string, batchToken?: string, options?: any): AxiosPromise<Array<V1Item>> {
            return V1ItemsApiFp(configuration).listItems(locationId, batchToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the modifier lists for a given location.
         * @summary ListModifierLists
         * @param {string} locationId The ID of the location to list modifier lists for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModifierLists(locationId: string, options?: any): AxiosPromise<Array<V1ModifierList>> {
            return V1ItemsApiFp(configuration).listModifierLists(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Favorites pages (in Square Point of Sale) for a given location.
         * @summary ListPages
         * @param {string} locationId The ID of the location to list Favorites pages for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPages(locationId: string, options?: any): AxiosPromise<Array<V1Page>> {
            return V1ItemsApiFp(configuration).listPages(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a fee assocation from an item so the fee is no longer automatically applied to the item in Square Point of Sale.
         * @summary RemoveFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} itemId The ID of the item to add the fee to.
         * @param {string} feeId The ID of the fee to apply.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFee(locationId: string, itemId: string, feeId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).removeFee(locationId, itemId, feeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a modifier list association from an item so the modifier options from the list can no longer be applied to the item.
         * @summary RemoveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to remove.
         * @param {string} itemId The ID of the item to remove the modifier list from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeModifierList(locationId: string, modifierListId: string, itemId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).removeModifierList(locationId, modifierListId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single item, including associated modifier lists and fees.
         * @summary RetrieveItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The item\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItem(locationId: string, itemId: string, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).retrieveItem(locationId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides the details for a single modifier list.
         * @summary RetrieveModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The modifier list\&#39;s ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModifierList(locationId: string, modifierListId: string, options?: any): AxiosPromise<V1ModifierList> {
            return V1ItemsApiFp(configuration).retrieveModifierList(locationId, modifierListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing item category.
         * @summary UpdateCategory
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} categoryId The ID of the category to edit.
         * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(locationId: string, categoryId: string, body: V1Category, options?: any): AxiosPromise<V1Category> {
            return V1ItemsApiFp(configuration).updateCategory(locationId, categoryId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing discount.
         * @summary UpdateDiscount
         * @param {string} locationId The ID of the category\&#39;s associated location.
         * @param {string} discountId The ID of the discount to edit.
         * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscount(locationId: string, discountId: string, body: V1Discount, options?: any): AxiosPromise<V1Discount> {
            return V1ItemsApiFp(configuration).updateDiscount(locationId, discountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing fee (tax).
         * @summary UpdateFee
         * @param {string} locationId The ID of the fee\&#39;s associated location.
         * @param {string} feeId The ID of the fee to edit.
         * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFee(locationId: string, feeId: string, body: V1Fee, options?: any): AxiosPromise<V1Fee> {
            return V1ItemsApiFp(configuration).updateFee(locationId, feeId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the core details of an existing item.
         * @summary UpdateItem
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(locationId: string, itemId: string, body: V1Item, options?: any): AxiosPromise<V1Item> {
            return V1ItemsApiFp(configuration).updateItem(locationId, itemId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing item modifier list.
         * @summary UpdateModifierList
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {V1UpdateModifierListRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModifierList(locationId: string, modifierListId: string, body: V1UpdateModifierListRequest, options?: any): AxiosPromise<V1ModifierList> {
            return V1ItemsApiFp(configuration).updateModifierList(locationId, modifierListId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing item modifier option.
         * @summary UpdateModifierOption
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} modifierListId The ID of the modifier list to edit.
         * @param {string} modifierOptionId The ID of the modifier list to edit.
         * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, body: V1ModifierOption, options?: any): AxiosPromise<V1ModifierOption> {
            return V1ItemsApiFp(configuration).updateModifierOption(locationId, modifierListId, modifierOptionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of a Favorites page in Square Point of Sale.
         * @summary UpdatePage
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location
         * @param {string} pageId The ID of the page to modify.
         * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage(locationId: string, pageId: string, body: V1Page, options?: any): AxiosPromise<V1Page> {
            return V1ItemsApiFp(configuration).updatePage(locationId, pageId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies a cell of a Favorites page in Square Point of Sale.
         * @summary UpdatePageCell
         * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
         * @param {string} pageId The ID of the page the cell belongs to.
         * @param {V1PageCell} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageCell(locationId: string, pageId: string, body: V1PageCell, options?: any): AxiosPromise<V1Page> {
            return V1ItemsApiFp(configuration).updatePageCell(locationId, pageId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies the details of an existing item variation.
         * @summary UpdateVariation
         * @param {string} locationId The ID of the item\&#39;s associated location.
         * @param {string} itemId The ID of the item to modify.
         * @param {string} variationId The ID of the variation to modify.
         * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVariation(locationId: string, itemId: string, variationId: string, body: V1Variation, options?: any): AxiosPromise<V1Variation> {
            return V1ItemsApiFp(configuration).updateVariation(locationId, itemId, variationId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1ItemsApi - object-oriented interface
 * @export
 * @class V1ItemsApi
 * @extends {BaseAPI}
 */
export class V1ItemsApi extends BaseAPI {
    /**
     * Adjusts the current available inventory of an item variation.
     * @summary AdjustInventory
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} variationId The ID of the variation to adjust inventory information for.
     * @param {V1AdjustInventoryRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public adjustInventory(locationId: string, variationId: string, body: V1AdjustInventoryRequest, options?: any) {
        return V1ItemsApiFp(this.configuration).adjustInventory(locationId, variationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associates a fee with an item so the fee is automatically applied to the item in Square Point of Sale.
     * @summary ApplyFee
     * @param {string} locationId The ID of the fee\&#39;s associated location.
     * @param {string} itemId The ID of the item to add the fee to.
     * @param {string} feeId The ID of the fee to apply.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public applyFee(locationId: string, itemId: string, feeId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).applyFee(locationId, itemId, feeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associates a modifier list with an item so the associated modifier options can be applied to the item.
     * @summary ApplyModifierList
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to apply.
     * @param {string} itemId The ID of the item to add the modifier list to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public applyModifierList(locationId: string, modifierListId: string, itemId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).applyModifierList(locationId, modifierListId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an item category.
     * @summary CreateCategory
     * @param {string} locationId The ID of the location to create an item for.
     * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createCategory(locationId: string, body: V1Category, options?: any) {
        return V1ItemsApiFp(this.configuration).createCategory(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a discount.
     * @summary CreateDiscount
     * @param {string} locationId The ID of the location to create an item for.
     * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createDiscount(locationId: string, body: V1Discount, options?: any) {
        return V1ItemsApiFp(this.configuration).createDiscount(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a fee (tax).
     * @summary CreateFee
     * @param {string} locationId The ID of the location to create a fee for.
     * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createFee(locationId: string, body: V1Fee, options?: any) {
        return V1ItemsApiFp(this.configuration).createFee(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an item and at least one variation for it.    Item-related entities include fields you can use to associate them with entities in a non-Square system.  When you create an item-related entity, you can optionally specify `id`. This value must be unique among all IDs ever specified for the account, including those specified by other applications. You can never reuse an entity ID. If you do not specify an ID, Square generates one for the entity.  Item variations have a `user_data` string that lets you associate arbitrary metadata with the variation. The string cannot exceed 255 characters.
     * @summary CreateItem
     * @param {string} locationId The ID of the location to create an item for.
     * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createItem(locationId: string, body: V1Item, options?: any) {
        return V1ItemsApiFp(this.configuration).createItem(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an item modifier list and at least 1 modifier option for it.
     * @summary CreateModifierList
     * @param {string} locationId The ID of the location to create a modifier list for.
     * @param {V1ModifierList} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createModifierList(locationId: string, body: V1ModifierList, options?: any) {
        return V1ItemsApiFp(this.configuration).createModifierList(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an item modifier option and adds it to a modifier list.
     * @summary CreateModifierOption
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to edit.
     * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createModifierOption(locationId: string, modifierListId: string, body: V1ModifierOption, options?: any) {
        return V1ItemsApiFp(this.configuration).createModifierOption(locationId, modifierListId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Favorites page in Square Point of Sale.
     * @summary CreatePage
     * @param {string} locationId The ID of the location to create an item for.
     * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createPage(locationId: string, body: V1Page, options?: any) {
        return V1ItemsApiFp(this.configuration).createPage(locationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an item variation for an existing item.
     * @summary CreateVariation
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The item\&#39;s ID.
     * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public createVariation(locationId: string, itemId: string, body: V1Variation, options?: any) {
        return V1ItemsApiFp(this.configuration).createVariation(locationId, itemId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing item category.   __DeleteCategory__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteCategoryRequest` object as documented below.
     * @summary DeleteCategory
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} categoryId The ID of the category to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteCategory(locationId: string, categoryId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteCategory(locationId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing discount.   __DeleteDiscount__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteDiscountRequest` object as documented below.
     * @summary DeleteDiscount
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} discountId The ID of the discount to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteDiscount(locationId: string, discountId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteDiscount(locationId, discountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing fee (tax).   __DeleteFee__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteFeeRequest` object as documented below.
     * @summary DeleteFee
     * @param {string} locationId The ID of the fee\&#39;s associated location.
     * @param {string} feeId The ID of the fee to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteFee(locationId: string, feeId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteFee(locationId, feeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing item and all item variations associated with it.   __DeleteItem__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteItemRequest` object as documented below.
     * @summary DeleteItem
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The ID of the item to modify.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteItem(locationId: string, itemId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteItem(locationId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing item modifier list and all modifier options associated with it.   __DeleteModifierList__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierListRequest` object as documented below.
     * @summary DeleteModifierList
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteModifierList(locationId: string, modifierListId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteModifierList(locationId, modifierListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing item modifier option from a modifier list.   __DeleteModifierOption__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteModifierOptionRequest` object.
     * @summary DeleteModifierOption
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to delete.
     * @param {string} modifierOptionId The ID of the modifier list to edit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteModifierOption(locationId, modifierListId, modifierOptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing Favorites page and all of its cells.   __DeletePage__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageRequest` object.
     * @summary DeletePage
     * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
     * @param {string} pageId The ID of the page to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deletePage(locationId: string, pageId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deletePage(locationId, pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a cell from a Favorites page in Square Point of Sale.   __DeletePageCell__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeletePageCellRequest` object as documented below.
     * @summary DeletePageCell
     * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
     * @param {string} pageId The ID of the page to delete.
     * @param {string} [row] The row of the cell to clear. Always an integer between 0 and 4, inclusive. Row 0 is the top row.
     * @param {string} [column] The column of the cell to clear. Always an integer between 0 and 4, inclusive. Column 0 is the leftmost column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deletePageCell(locationId: string, pageId: string, row?: string, column?: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deletePageCell(locationId, pageId, row, column, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing item variation from an item.   __DeleteVariation__ returns nothing on success but Connect SDKs map the empty response to an empty `V1DeleteVariationRequest` object as documented below.
     * @summary DeleteVariation
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The ID of the item to delete.
     * @param {string} variationId The ID of the variation to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public deleteVariation(locationId: string, itemId: string, variationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).deleteVariation(locationId, itemId, variationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the item categories for a given location.
     * @summary ListCategories
     * @param {string} locationId The ID of the location to list categories for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listCategories(locationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listCategories(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the discounts for a given location.
     * @summary ListDiscounts
     * @param {string} locationId The ID of the location to list categories for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listDiscounts(locationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listDiscounts(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the fees (taxes) for a given location.
     * @summary ListFees
     * @param {string} locationId The ID of the location to list fees for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listFees(locationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listFees(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides inventory information for all inventory-enabled item variations.
     * @summary ListInventory
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {number} [limit] The maximum number of inventory entries to return in a single response. This value cannot exceed 1000.
     * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listInventory(locationId: string, limit?: number, batchToken?: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listInventory(locationId, limit, batchToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides summary information of all items for a given location.
     * @summary ListItems
     * @param {string} locationId The ID of the location to list items for.
     * @param {string} [batchToken] A pagination cursor to retrieve the next set of results for your original query to the endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listItems(locationId: string, batchToken?: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listItems(locationId, batchToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the modifier lists for a given location.
     * @summary ListModifierLists
     * @param {string} locationId The ID of the location to list modifier lists for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listModifierLists(locationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listModifierLists(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Favorites pages (in Square Point of Sale) for a given location.
     * @summary ListPages
     * @param {string} locationId The ID of the location to list Favorites pages for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public listPages(locationId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).listPages(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a fee assocation from an item so the fee is no longer automatically applied to the item in Square Point of Sale.
     * @summary RemoveFee
     * @param {string} locationId The ID of the fee\&#39;s associated location.
     * @param {string} itemId The ID of the item to add the fee to.
     * @param {string} feeId The ID of the fee to apply.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public removeFee(locationId: string, itemId: string, feeId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).removeFee(locationId, itemId, feeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a modifier list association from an item so the modifier options from the list can no longer be applied to the item.
     * @summary RemoveModifierList
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to remove.
     * @param {string} itemId The ID of the item to remove the modifier list from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public removeModifierList(locationId: string, modifierListId: string, itemId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).removeModifierList(locationId, modifierListId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single item, including associated modifier lists and fees.
     * @summary RetrieveItem
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The item\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public retrieveItem(locationId: string, itemId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).retrieveItem(locationId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides the details for a single modifier list.
     * @summary RetrieveModifierList
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The modifier list\&#39;s ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public retrieveModifierList(locationId: string, modifierListId: string, options?: any) {
        return V1ItemsApiFp(this.configuration).retrieveModifierList(locationId, modifierListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing item category.
     * @summary UpdateCategory
     * @param {string} locationId The ID of the category\&#39;s associated location.
     * @param {string} categoryId The ID of the category to edit.
     * @param {V1Category} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateCategory(locationId: string, categoryId: string, body: V1Category, options?: any) {
        return V1ItemsApiFp(this.configuration).updateCategory(locationId, categoryId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing discount.
     * @summary UpdateDiscount
     * @param {string} locationId The ID of the category\&#39;s associated location.
     * @param {string} discountId The ID of the discount to edit.
     * @param {V1Discount} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateDiscount(locationId: string, discountId: string, body: V1Discount, options?: any) {
        return V1ItemsApiFp(this.configuration).updateDiscount(locationId, discountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing fee (tax).
     * @summary UpdateFee
     * @param {string} locationId The ID of the fee\&#39;s associated location.
     * @param {string} feeId The ID of the fee to edit.
     * @param {V1Fee} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateFee(locationId: string, feeId: string, body: V1Fee, options?: any) {
        return V1ItemsApiFp(this.configuration).updateFee(locationId, feeId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the core details of an existing item.
     * @summary UpdateItem
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The ID of the item to modify.
     * @param {V1Item} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateItem(locationId: string, itemId: string, body: V1Item, options?: any) {
        return V1ItemsApiFp(this.configuration).updateItem(locationId, itemId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing item modifier list.
     * @summary UpdateModifierList
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to edit.
     * @param {V1UpdateModifierListRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateModifierList(locationId: string, modifierListId: string, body: V1UpdateModifierListRequest, options?: any) {
        return V1ItemsApiFp(this.configuration).updateModifierList(locationId, modifierListId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing item modifier option.
     * @summary UpdateModifierOption
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} modifierListId The ID of the modifier list to edit.
     * @param {string} modifierOptionId The ID of the modifier list to edit.
     * @param {V1ModifierOption} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateModifierOption(locationId: string, modifierListId: string, modifierOptionId: string, body: V1ModifierOption, options?: any) {
        return V1ItemsApiFp(this.configuration).updateModifierOption(locationId, modifierListId, modifierOptionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of a Favorites page in Square Point of Sale.
     * @summary UpdatePage
     * @param {string} locationId The ID of the Favorites page\&#39;s associated location
     * @param {string} pageId The ID of the page to modify.
     * @param {V1Page} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updatePage(locationId: string, pageId: string, body: V1Page, options?: any) {
        return V1ItemsApiFp(this.configuration).updatePage(locationId, pageId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies a cell of a Favorites page in Square Point of Sale.
     * @summary UpdatePageCell
     * @param {string} locationId The ID of the Favorites page\&#39;s associated location.
     * @param {string} pageId The ID of the page the cell belongs to.
     * @param {V1PageCell} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updatePageCell(locationId: string, pageId: string, body: V1PageCell, options?: any) {
        return V1ItemsApiFp(this.configuration).updatePageCell(locationId, pageId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies the details of an existing item variation.
     * @summary UpdateVariation
     * @param {string} locationId The ID of the item\&#39;s associated location.
     * @param {string} itemId The ID of the item to modify.
     * @param {string} variationId The ID of the variation to modify.
     * @param {V1Variation} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ItemsApi
     */
    public updateVariation(locationId: string, itemId: string, variationId: string, body: V1Variation, options?: any) {
        return V1ItemsApiFp(this.configuration).updateVariation(locationId, itemId, variationId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
