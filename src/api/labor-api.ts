/* tslint:disable */
/* eslint-disable */
/**
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CreateBreakTypeRequest } from '../models';
// @ts-ignore
import { CreateBreakTypeResponse } from '../models';
// @ts-ignore
import { CreateShiftRequest } from '../models';
// @ts-ignore
import { CreateShiftResponse } from '../models';
// @ts-ignore
import { DeleteBreakTypeResponse } from '../models';
// @ts-ignore
import { DeleteShiftResponse } from '../models';
// @ts-ignore
import { GetBreakTypeResponse } from '../models';
// @ts-ignore
import { GetEmployeeWageResponse } from '../models';
// @ts-ignore
import { GetShiftResponse } from '../models';
// @ts-ignore
import { GetTeamMemberWageResponse } from '../models';
// @ts-ignore
import { ListBreakTypesResponse } from '../models';
// @ts-ignore
import { ListEmployeeWagesResponse } from '../models';
// @ts-ignore
import { ListTeamMemberWagesResponse } from '../models';
// @ts-ignore
import { ListWorkweekConfigsResponse } from '../models';
// @ts-ignore
import { SearchShiftsRequest } from '../models';
// @ts-ignore
import { SearchShiftsResponse } from '../models';
// @ts-ignore
import { UpdateBreakTypeRequest } from '../models';
// @ts-ignore
import { UpdateBreakTypeResponse } from '../models';
// @ts-ignore
import { UpdateShiftRequest } from '../models';
// @ts-ignore
import { UpdateShiftResponse } from '../models';
// @ts-ignore
import { UpdateWorkweekConfigRequest } from '../models';
// @ts-ignore
import { UpdateWorkweekConfigResponse } from '../models';
/**
 * LaborApi - axios parameter creator
 * @export
 */
export const LaborApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new `BreakType`.  A `BreakType` is a template for creating `Break` objects. You must provide the following values in your request to this endpoint:  - `location_id` - `break_name` - `expected_duration` - `is_paid`  You can only have 3 `BreakType` instances per location. If you attempt to add a 4th `BreakType` for a location, an `INVALID_REQUEST_ERROR` \"Exceeded limit of 3 breaks per location.\" is returned.
         * @summary CreateBreakType
         * @param {CreateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBreakType: async (body: CreateBreakTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBreakType.');
            }
            const localVarPath = `/v2/labor/break-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new `Shift`.  A `Shift` represents a complete work day for a single employee. You must provide the following values in your request to this endpoint:  - `location_id` - `employee_id` - `start_at`  An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when: - The `status` of the new `Shift` is `OPEN` and the employee has another shift with an `OPEN` status. - The `start_at` date is in the future - the `start_at` or `end_at` overlaps another shift for the same employee - If `Break`s are set in the request, a break `start_at` must not be before the `Shift.start_at`. A break `end_at` must not be after the `Shift.end_at`
         * @summary CreateShift
         * @param {CreateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShift: async (body: CreateShiftRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createShift.');
            }
            const localVarPath = `/v2/labor/shifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing `BreakType`.  A `BreakType` can be deleted even if it is referenced from a `Shift`.
         * @summary DeleteBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBreakType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBreakType.');
            }
            const localVarPath = `/v2/labor/break-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a `Shift`.
         * @summary DeleteShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShift: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShift.');
            }
            const localVarPath = `/v2/labor/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single `BreakType` specified by id.
         * @summary GetBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBreakType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBreakType.');
            }
            const localVarPath = `/v2/labor/break-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single `EmployeeWage` specified by id.
         * @summary GetEmployeeWage
         * @param {string} id UUID for the &#x60;EmployeeWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeWage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getEmployeeWage.');
            }
            const localVarPath = `/v2/labor/employee-wages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single `Shift` specified by id.
         * @summary GetShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShift: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShift.');
            }
            const localVarPath = `/v2/labor/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single `TeamMemberWage` specified by id.
         * @summary GetTeamMemberWage
         * @param {string} id UUID for the &#x60;TeamMemberWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMemberWage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeamMemberWage.');
            }
            const localVarPath = `/v2/labor/team-member-wages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of `BreakType` instances for a business.
         * @summary ListBreakTypes
         * @param {string} [locationId] Filter Break Types returned to only those that are associated with the specified location.
         * @param {number} [limit] Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Break Type results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreakTypes: async (locationId?: string, limit?: number, cursor?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/labor/break-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (locationId !== undefined) {
                localVarQueryParameter['location_id'] = locationId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of `EmployeeWage` instances for a business.
         * @summary ListEmployeeWages
         * @param {string} [employeeId] Filter wages returned to only those that are associated with the specified employee.
         * @param {number} [limit] Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployeeWages: async (employeeId?: string, limit?: number, cursor?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/labor/employee-wages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employee_id'] = employeeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of `TeamMemberWage` instances for a business.
         * @summary ListTeamMemberWages
         * @param {string} [teamMemberId] Filter wages returned to only those that are associated with the specified team member.
         * @param {number} [limit] Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMemberWages: async (teamMemberId?: string, limit?: number, cursor?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/labor/team-member-wages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["EMPLOYEES_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (teamMemberId !== undefined) {
                localVarQueryParameter['team_member_id'] = teamMemberId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of `WorkweekConfig` instances for a business.
         * @summary ListWorkweekConfigs
         * @param {number} [limit] Maximum number of Workweek Configs to return per page.
         * @param {string} [cursor] Pointer to the next page of Workweek Config results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkweekConfigs: async (limit?: number, cursor?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/labor/workweek-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of `Shift` records for a business. The list to be returned can be filtered by: - Location IDs **and** - employee IDs **and** - shift status (`OPEN`, `CLOSED`) **and** - shift start **and** - shift end **and** - work day details  The list can be sorted by: - `start_at` - `end_at` - `created_at` - `updated_at`
         * @summary SearchShifts
         * @param {SearchShiftsRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchShifts: async (body: SearchShiftsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchShifts.');
            }
            const localVarPath = `/v2/labor/shifts/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing `BreakType`.
         * @summary UpdateBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being updated.
         * @param {UpdateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBreakType: async (id: string, body: UpdateBreakTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBreakType.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBreakType.');
            }
            const localVarPath = `/v2/labor/break-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_WRITE", "TIMECARDS_SETTINGS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing `Shift`.  When adding a `Break` to a `Shift`, any earlier `Breaks` in the `Shift` have the `end_at` property set to a valid RFC-3339 datetime string.  When closing a `Shift`, all `Break` instances in the shift must be complete with `end_at` set on each `Break`.
         * @summary UpdateShift
         * @param {string} id ID of the object being updated.
         * @param {UpdateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShift: async (id: string, body: UpdateShiftRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShift.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateShift.');
            }
            const localVarPath = `/v2/labor/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_WRITE", "TIMECARDS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a `WorkweekConfig`.
         * @summary UpdateWorkweekConfig
         * @param {string} id UUID for the &#x60;WorkweekConfig&#x60; object being updated.
         * @param {UpdateWorkweekConfigRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkweekConfig: async (id: string, body: UpdateWorkweekConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateWorkweekConfig.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateWorkweekConfig.');
            }
            const localVarPath = `/v2/labor/workweek-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["TIMECARDS_SETTINGS_WRITE", "TIMECARDS_SETTINGS_READ"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LaborApi - functional programming interface
 * @export
 */
export const LaborApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new `BreakType`.  A `BreakType` is a template for creating `Break` objects. You must provide the following values in your request to this endpoint:  - `location_id` - `break_name` - `expected_duration` - `is_paid`  You can only have 3 `BreakType` instances per location. If you attempt to add a 4th `BreakType` for a location, an `INVALID_REQUEST_ERROR` \"Exceeded limit of 3 breaks per location.\" is returned.
         * @summary CreateBreakType
         * @param {CreateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBreakType(body: CreateBreakTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBreakTypeResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).createBreakType(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new `Shift`.  A `Shift` represents a complete work day for a single employee. You must provide the following values in your request to this endpoint:  - `location_id` - `employee_id` - `start_at`  An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when: - The `status` of the new `Shift` is `OPEN` and the employee has another shift with an `OPEN` status. - The `start_at` date is in the future - the `start_at` or `end_at` overlaps another shift for the same employee - If `Break`s are set in the request, a break `start_at` must not be before the `Shift.start_at`. A break `end_at` must not be after the `Shift.end_at`
         * @summary CreateShift
         * @param {CreateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShift(body: CreateShiftRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShiftResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).createShift(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing `BreakType`.  A `BreakType` can be deleted even if it is referenced from a `Shift`.
         * @summary DeleteBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBreakType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteBreakTypeResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).deleteBreakType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a `Shift`.
         * @summary DeleteShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShift(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteShiftResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).deleteShift(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single `BreakType` specified by id.
         * @summary GetBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBreakType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBreakTypeResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).getBreakType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single `EmployeeWage` specified by id.
         * @summary GetEmployeeWage
         * @param {string} id UUID for the &#x60;EmployeeWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployeeWage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmployeeWageResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).getEmployeeWage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single `Shift` specified by id.
         * @summary GetShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShift(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShiftResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).getShift(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single `TeamMemberWage` specified by id.
         * @summary GetTeamMemberWage
         * @param {string} id UUID for the &#x60;TeamMemberWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamMemberWage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamMemberWageResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).getTeamMemberWage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of `BreakType` instances for a business.
         * @summary ListBreakTypes
         * @param {string} [locationId] Filter Break Types returned to only those that are associated with the specified location.
         * @param {number} [limit] Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Break Type results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBreakTypes(locationId?: string, limit?: number, cursor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBreakTypesResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).listBreakTypes(locationId, limit, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of `EmployeeWage` instances for a business.
         * @summary ListEmployeeWages
         * @param {string} [employeeId] Filter wages returned to only those that are associated with the specified employee.
         * @param {number} [limit] Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmployeeWages(employeeId?: string, limit?: number, cursor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEmployeeWagesResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).listEmployeeWages(employeeId, limit, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of `TeamMemberWage` instances for a business.
         * @summary ListTeamMemberWages
         * @param {string} [teamMemberId] Filter wages returned to only those that are associated with the specified team member.
         * @param {number} [limit] Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamMemberWages(teamMemberId?: string, limit?: number, cursor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTeamMemberWagesResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).listTeamMemberWages(teamMemberId, limit, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of `WorkweekConfig` instances for a business.
         * @summary ListWorkweekConfigs
         * @param {number} [limit] Maximum number of Workweek Configs to return per page.
         * @param {string} [cursor] Pointer to the next page of Workweek Config results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkweekConfigs(limit?: number, cursor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkweekConfigsResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).listWorkweekConfigs(limit, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of `Shift` records for a business. The list to be returned can be filtered by: - Location IDs **and** - employee IDs **and** - shift status (`OPEN`, `CLOSED`) **and** - shift start **and** - shift end **and** - work day details  The list can be sorted by: - `start_at` - `end_at` - `created_at` - `updated_at`
         * @summary SearchShifts
         * @param {SearchShiftsRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchShifts(body: SearchShiftsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchShiftsResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).searchShifts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing `BreakType`.
         * @summary UpdateBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being updated.
         * @param {UpdateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBreakType(id: string, body: UpdateBreakTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateBreakTypeResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).updateBreakType(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing `Shift`.  When adding a `Break` to a `Shift`, any earlier `Breaks` in the `Shift` have the `end_at` property set to a valid RFC-3339 datetime string.  When closing a `Shift`, all `Break` instances in the shift must be complete with `end_at` set on each `Break`.
         * @summary UpdateShift
         * @param {string} id ID of the object being updated.
         * @param {UpdateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShift(id: string, body: UpdateShiftRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateShiftResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).updateShift(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a `WorkweekConfig`.
         * @summary UpdateWorkweekConfig
         * @param {string} id UUID for the &#x60;WorkweekConfig&#x60; object being updated.
         * @param {UpdateWorkweekConfigRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkweekConfig(id: string, body: UpdateWorkweekConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkweekConfigResponse>> {
            const localVarAxiosArgs = await LaborApiAxiosParamCreator(configuration).updateWorkweekConfig(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LaborApi - factory interface
 * @export
 */
export const LaborApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new `BreakType`.  A `BreakType` is a template for creating `Break` objects. You must provide the following values in your request to this endpoint:  - `location_id` - `break_name` - `expected_duration` - `is_paid`  You can only have 3 `BreakType` instances per location. If you attempt to add a 4th `BreakType` for a location, an `INVALID_REQUEST_ERROR` \"Exceeded limit of 3 breaks per location.\" is returned.
         * @summary CreateBreakType
         * @param {CreateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBreakType(body: CreateBreakTypeRequest, options?: any): AxiosPromise<CreateBreakTypeResponse> {
            return LaborApiFp(configuration).createBreakType(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new `Shift`.  A `Shift` represents a complete work day for a single employee. You must provide the following values in your request to this endpoint:  - `location_id` - `employee_id` - `start_at`  An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when: - The `status` of the new `Shift` is `OPEN` and the employee has another shift with an `OPEN` status. - The `start_at` date is in the future - the `start_at` or `end_at` overlaps another shift for the same employee - If `Break`s are set in the request, a break `start_at` must not be before the `Shift.start_at`. A break `end_at` must not be after the `Shift.end_at`
         * @summary CreateShift
         * @param {CreateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShift(body: CreateShiftRequest, options?: any): AxiosPromise<CreateShiftResponse> {
            return LaborApiFp(configuration).createShift(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing `BreakType`.  A `BreakType` can be deleted even if it is referenced from a `Shift`.
         * @summary DeleteBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBreakType(id: string, options?: any): AxiosPromise<DeleteBreakTypeResponse> {
            return LaborApiFp(configuration).deleteBreakType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a `Shift`.
         * @summary DeleteShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShift(id: string, options?: any): AxiosPromise<DeleteShiftResponse> {
            return LaborApiFp(configuration).deleteShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single `BreakType` specified by id.
         * @summary GetBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBreakType(id: string, options?: any): AxiosPromise<GetBreakTypeResponse> {
            return LaborApiFp(configuration).getBreakType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single `EmployeeWage` specified by id.
         * @summary GetEmployeeWage
         * @param {string} id UUID for the &#x60;EmployeeWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeWage(id: string, options?: any): AxiosPromise<GetEmployeeWageResponse> {
            return LaborApiFp(configuration).getEmployeeWage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single `Shift` specified by id.
         * @summary GetShift
         * @param {string} id UUID for the &#x60;Shift&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShift(id: string, options?: any): AxiosPromise<GetShiftResponse> {
            return LaborApiFp(configuration).getShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single `TeamMemberWage` specified by id.
         * @summary GetTeamMemberWage
         * @param {string} id UUID for the &#x60;TeamMemberWage&#x60; being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMemberWage(id: string, options?: any): AxiosPromise<GetTeamMemberWageResponse> {
            return LaborApiFp(configuration).getTeamMemberWage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of `BreakType` instances for a business.
         * @summary ListBreakTypes
         * @param {string} [locationId] Filter Break Types returned to only those that are associated with the specified location.
         * @param {number} [limit] Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Break Type results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreakTypes(locationId?: string, limit?: number, cursor?: string, options?: any): AxiosPromise<ListBreakTypesResponse> {
            return LaborApiFp(configuration).listBreakTypes(locationId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of `EmployeeWage` instances for a business.
         * @summary ListEmployeeWages
         * @param {string} [employeeId] Filter wages returned to only those that are associated with the specified employee.
         * @param {number} [limit] Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmployeeWages(employeeId?: string, limit?: number, cursor?: string, options?: any): AxiosPromise<ListEmployeeWagesResponse> {
            return LaborApiFp(configuration).listEmployeeWages(employeeId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of `TeamMemberWage` instances for a business.
         * @summary ListTeamMemberWages
         * @param {string} [teamMemberId] Filter wages returned to only those that are associated with the specified team member.
         * @param {number} [limit] Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
         * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMemberWages(teamMemberId?: string, limit?: number, cursor?: string, options?: any): AxiosPromise<ListTeamMemberWagesResponse> {
            return LaborApiFp(configuration).listTeamMemberWages(teamMemberId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of `WorkweekConfig` instances for a business.
         * @summary ListWorkweekConfigs
         * @param {number} [limit] Maximum number of Workweek Configs to return per page.
         * @param {string} [cursor] Pointer to the next page of Workweek Config results to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkweekConfigs(limit?: number, cursor?: string, options?: any): AxiosPromise<ListWorkweekConfigsResponse> {
            return LaborApiFp(configuration).listWorkweekConfigs(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of `Shift` records for a business. The list to be returned can be filtered by: - Location IDs **and** - employee IDs **and** - shift status (`OPEN`, `CLOSED`) **and** - shift start **and** - shift end **and** - work day details  The list can be sorted by: - `start_at` - `end_at` - `created_at` - `updated_at`
         * @summary SearchShifts
         * @param {SearchShiftsRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchShifts(body: SearchShiftsRequest, options?: any): AxiosPromise<SearchShiftsResponse> {
            return LaborApiFp(configuration).searchShifts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing `BreakType`.
         * @summary UpdateBreakType
         * @param {string} id UUID for the &#x60;BreakType&#x60; being updated.
         * @param {UpdateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBreakType(id: string, body: UpdateBreakTypeRequest, options?: any): AxiosPromise<UpdateBreakTypeResponse> {
            return LaborApiFp(configuration).updateBreakType(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing `Shift`.  When adding a `Break` to a `Shift`, any earlier `Breaks` in the `Shift` have the `end_at` property set to a valid RFC-3339 datetime string.  When closing a `Shift`, all `Break` instances in the shift must be complete with `end_at` set on each `Break`.
         * @summary UpdateShift
         * @param {string} id ID of the object being updated.
         * @param {UpdateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShift(id: string, body: UpdateShiftRequest, options?: any): AxiosPromise<UpdateShiftResponse> {
            return LaborApiFp(configuration).updateShift(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a `WorkweekConfig`.
         * @summary UpdateWorkweekConfig
         * @param {string} id UUID for the &#x60;WorkweekConfig&#x60; object being updated.
         * @param {UpdateWorkweekConfigRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkweekConfig(id: string, body: UpdateWorkweekConfigRequest, options?: any): AxiosPromise<UpdateWorkweekConfigResponse> {
            return LaborApiFp(configuration).updateWorkweekConfig(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LaborApi - object-oriented interface
 * @export
 * @class LaborApi
 * @extends {BaseAPI}
 */
export class LaborApi extends BaseAPI {
    /**
     * Creates a new `BreakType`.  A `BreakType` is a template for creating `Break` objects. You must provide the following values in your request to this endpoint:  - `location_id` - `break_name` - `expected_duration` - `is_paid`  You can only have 3 `BreakType` instances per location. If you attempt to add a 4th `BreakType` for a location, an `INVALID_REQUEST_ERROR` \"Exceeded limit of 3 breaks per location.\" is returned.
     * @summary CreateBreakType
     * @param {CreateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public createBreakType(body: CreateBreakTypeRequest, options?: any) {
        return LaborApiFp(this.configuration).createBreakType(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new `Shift`.  A `Shift` represents a complete work day for a single employee. You must provide the following values in your request to this endpoint:  - `location_id` - `employee_id` - `start_at`  An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when: - The `status` of the new `Shift` is `OPEN` and the employee has another shift with an `OPEN` status. - The `start_at` date is in the future - the `start_at` or `end_at` overlaps another shift for the same employee - If `Break`s are set in the request, a break `start_at` must not be before the `Shift.start_at`. A break `end_at` must not be after the `Shift.end_at`
     * @summary CreateShift
     * @param {CreateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public createShift(body: CreateShiftRequest, options?: any) {
        return LaborApiFp(this.configuration).createShift(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing `BreakType`.  A `BreakType` can be deleted even if it is referenced from a `Shift`.
     * @summary DeleteBreakType
     * @param {string} id UUID for the &#x60;BreakType&#x60; being deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public deleteBreakType(id: string, options?: any) {
        return LaborApiFp(this.configuration).deleteBreakType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a `Shift`.
     * @summary DeleteShift
     * @param {string} id UUID for the &#x60;Shift&#x60; being deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public deleteShift(id: string, options?: any) {
        return LaborApiFp(this.configuration).deleteShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single `BreakType` specified by id.
     * @summary GetBreakType
     * @param {string} id UUID for the &#x60;BreakType&#x60; being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public getBreakType(id: string, options?: any) {
        return LaborApiFp(this.configuration).getBreakType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single `EmployeeWage` specified by id.
     * @summary GetEmployeeWage
     * @param {string} id UUID for the &#x60;EmployeeWage&#x60; being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public getEmployeeWage(id: string, options?: any) {
        return LaborApiFp(this.configuration).getEmployeeWage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single `Shift` specified by id.
     * @summary GetShift
     * @param {string} id UUID for the &#x60;Shift&#x60; being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public getShift(id: string, options?: any) {
        return LaborApiFp(this.configuration).getShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single `TeamMemberWage` specified by id.
     * @summary GetTeamMemberWage
     * @param {string} id UUID for the &#x60;TeamMemberWage&#x60; being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public getTeamMemberWage(id: string, options?: any) {
        return LaborApiFp(this.configuration).getTeamMemberWage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of `BreakType` instances for a business.
     * @summary ListBreakTypes
     * @param {string} [locationId] Filter Break Types returned to only those that are associated with the specified location.
     * @param {number} [limit] Maximum number of Break Types to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param {string} [cursor] Pointer to the next page of Break Type results to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public listBreakTypes(locationId?: string, limit?: number, cursor?: string, options?: any) {
        return LaborApiFp(this.configuration).listBreakTypes(locationId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of `EmployeeWage` instances for a business.
     * @summary ListEmployeeWages
     * @param {string} [employeeId] Filter wages returned to only those that are associated with the specified employee.
     * @param {number} [limit] Maximum number of Employee Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public listEmployeeWages(employeeId?: string, limit?: number, cursor?: string, options?: any) {
        return LaborApiFp(this.configuration).listEmployeeWages(employeeId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of `TeamMemberWage` instances for a business.
     * @summary ListTeamMemberWages
     * @param {string} [teamMemberId] Filter wages returned to only those that are associated with the specified team member.
     * @param {number} [limit] Maximum number of Team Member Wages to return per page. Can range between 1 and 200. The default is the maximum at 200.
     * @param {string} [cursor] Pointer to the next page of Employee Wage results to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public listTeamMemberWages(teamMemberId?: string, limit?: number, cursor?: string, options?: any) {
        return LaborApiFp(this.configuration).listTeamMemberWages(teamMemberId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of `WorkweekConfig` instances for a business.
     * @summary ListWorkweekConfigs
     * @param {number} [limit] Maximum number of Workweek Configs to return per page.
     * @param {string} [cursor] Pointer to the next page of Workweek Config results to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public listWorkweekConfigs(limit?: number, cursor?: string, options?: any) {
        return LaborApiFp(this.configuration).listWorkweekConfigs(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of `Shift` records for a business. The list to be returned can be filtered by: - Location IDs **and** - employee IDs **and** - shift status (`OPEN`, `CLOSED`) **and** - shift start **and** - shift end **and** - work day details  The list can be sorted by: - `start_at` - `end_at` - `created_at` - `updated_at`
     * @summary SearchShifts
     * @param {SearchShiftsRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public searchShifts(body: SearchShiftsRequest, options?: any) {
        return LaborApiFp(this.configuration).searchShifts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing `BreakType`.
     * @summary UpdateBreakType
     * @param {string} id UUID for the &#x60;BreakType&#x60; being updated.
     * @param {UpdateBreakTypeRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public updateBreakType(id: string, body: UpdateBreakTypeRequest, options?: any) {
        return LaborApiFp(this.configuration).updateBreakType(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing `Shift`.  When adding a `Break` to a `Shift`, any earlier `Breaks` in the `Shift` have the `end_at` property set to a valid RFC-3339 datetime string.  When closing a `Shift`, all `Break` instances in the shift must be complete with `end_at` set on each `Break`.
     * @summary UpdateShift
     * @param {string} id ID of the object being updated.
     * @param {UpdateShiftRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public updateShift(id: string, body: UpdateShiftRequest, options?: any) {
        return LaborApiFp(this.configuration).updateShift(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a `WorkweekConfig`.
     * @summary UpdateWorkweekConfig
     * @param {string} id UUID for the &#x60;WorkweekConfig&#x60; object being updated.
     * @param {UpdateWorkweekConfigRequest} body An object containing the fields to POST for the request.  See the corresponding object definition for field details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaborApi
     */
    public updateWorkweekConfig(id: string, body: UpdateWorkweekConfigRequest, options?: any) {
        return LaborApiFp(this.configuration).updateWorkweekConfig(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
